/**
 * Realistic Webpack Bundle Analysis
 *
 * Key question: When a server action imports ejs, what gets bundled?
 *
 * In webpack, each chunk contains specific modules. The manifest maps:
 *   actionId -> { id: chunkId, name: exportName }
 *
 * The moduleExports from __webpack_require__(chunkId) contains
 * ONLY the exports of THAT specific module, not imported modules.
 */

console.log("=== Webpack Bundle Reality Check ===\n");

// Example: What a server action file looks like
const serverActionSource = `
// app/actions.ts
"use server";
import ejs from 'ejs';

export async function sendEmail(to: string, template: string, data: object) {
  const html = ejs.render(template, data);
  // ... send email
  return { success: true };
}

export async function processForm(formData: FormData) {
  return { processed: true };
}
`;

console.log("Server action source:");
console.log(serverActionSource);

console.log("\n=== How Webpack Bundles This ===");
console.log(`
When webpack bundles this file:

1. The server action file becomes its own module/chunk
2. ejs becomes a SEPARATE module (usually in node_modules chunk)
3. The manifest entry points to the SERVER ACTIONS chunk, not ejs

Manifest entry:
{
  "sendEmail-action-id": {
    id: "app-actions-chunk",    // Points to the server actions module
    name: "sendEmail"            // The export name
  }
}

__webpack_require__("app-actions-chunk") returns:
{
  sendEmail: [Function],
  processForm: [Function]
}

NOT:
{
  sendEmail: [Function],
  processForm: [Function],
  render: [ejs.render],      // ejs is NOT re-exported!
}
`);

console.log("=== The Fundamental Limitation ===");
console.log(`
The vulnerability allows: moduleExports[attackerControlled]

Where moduleExports = __webpack_require__(manifestEntry.id)

The manifest entry's 'id' points to the SERVER ACTIONS module,
which only exports the 'use server' functions, NOT imported modules.

ejs.render is in a DIFFERENT webpack module with a DIFFERENT id.
The attacker cannot control which webpack module gets loaded!
`);

console.log("\n=== Could There Be an Exception? ===");
console.log(`
Scenarios where dangerous modules MIGHT be in the same chunk:

1. Barrel exports / re-exports:
   // actions.ts
   export { render } from 'ejs';  // Explicitly re-exports ejs.render
   export async function myAction() {...}

2. Webpack externals misconfiguration:
   // webpack.config.js
   externals: {
     ejs: 'commonjs ejs'  // ejs loaded via require at runtime
   }
   // If ejs is external, __webpack_require__ might return the real ejs module

3. Custom bundler that doesn't tree-shake:
   // All imports become exports (very unusual)

4. Monorepo with shared chunks:
   // Multiple modules bundled into one chunk
   // Server actions + ejs in same chunk
`);

console.log("\n=== Testing Webpack Externals Scenario ===");

// Simulate webpack externals - ejs is loaded at runtime
global.__webpack_require__ = function(id) {
  // Externals: ejs resolves to require('ejs')
  if (id === 'ejs') return require('ejs');
  if (id === 'server-actions') {
    return {
      myAction: async () => "action result"
    };
  }
  throw new Error(`Module not found: ${id}`);
};

// If the manifest incorrectly points to 'ejs' module:
const maliciousManifest = {
  "legit-action-id": {
    id: "ejs",  // Points directly to ejs module!
    name: "render"
  }
};

console.log("If manifest points to ejs module directly:");
const metadata = [maliciousManifest["legit-action-id"].id, [], maliciousManifest["legit-action-id"].name];
const moduleExports = global.__webpack_require__(metadata[0]);
const fn = moduleExports[metadata[2]];
console.log("Got function:", fn.name || fn);

if (typeof fn === 'function') {
  try {
    const result = fn("<%= process.mainModule.require('child_process').execSync('whoami').toString() %>");
    console.log("RCE Result:", result);
  } catch(e) {
    console.log("Error:", e.message);
  }
}

console.log("\n=== CONCLUSION ===");
console.log(`
For CVE-2025-55182 to work against template engines:

1. The manifest must have an entry where 'id' points to ejs/pug chunk
2. This requires EITHER:
   a. Explicit re-export: export { render } from 'ejs'
   b. Misconfigured externals where module ID maps to ejs
   c. All-in-one bundle with no code splitting
   d. The attacker can somehow control the manifest entry's 'id' field

The attacker only controls:
- The full 'id' string sent in the request (parsed as moduleId#exportName)
- The bound arguments

The attacker does NOT control:
- Which webpack module IDs exist
- The mapping from action ID to webpack module ID (build-time)
`);
