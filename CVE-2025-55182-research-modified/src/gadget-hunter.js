/**
 * Gadget Hunter - Find exploitable exports in common npm packages
 *
 * We need a function that:
 * 1. Is exported by a commonly bundled module
 * 2. Executes user-controlled code when called with user-controlled args
 */

const fs = require('fs');
const path = require('path');

console.log("=== Gadget Hunter for CVE-2025-55182 ===\n");

// List of modules commonly bundled in server-side apps
const modulesToCheck = [
  'util',
  'path',
  'url',
  'querystring',
  'events',
  'stream',
  'buffer',
  'assert',
  'os',
  'crypto',
  'zlib',
  'http',
  'https',
  'net',
  'tls',
  'dns',
];

// Dangerous function signatures we're looking for
const dangerousPatterns = [
  'Function',      // The Function constructor
  'eval',          // Direct eval
  'exec',          // Command execution
  'spawn',         // Process spawning
  'fork',          // Process forking
  'runInContext',  // VM execution
  'compileFunction', // VM compilation
  'Script',        // VM Script
];

console.log("=== Checking Node.js built-in modules ===\n");

for (const modName of modulesToCheck) {
  try {
    const mod = require(modName);
    const exports = Object.keys(mod);

    // Check each export
    for (const key of exports) {
      const value = mod[key];

      // Check if it's the Function constructor itself
      if (value === Function) {
        console.log(`CRITICAL: ${modName}.${key} === Function`);
      }

      // Check if it's a function that might be dangerous
      if (typeof value === 'function') {
        const fnString = value.toString().slice(0, 200);

        // Check if function name matches dangerous patterns
        for (const pattern of dangerousPatterns) {
          if (key.toLowerCase().includes(pattern.toLowerCase())) {
            console.log(`POTENTIAL: ${modName}.${key} - name matches '${pattern}'`);
          }
        }
      }
    }
  } catch (e) {
    // Module not available or error
  }
}

console.log("\n=== Checking if any module re-exports global constructors ===\n");

// Check util module specifically - it has some interesting functions
const util = require('util');
console.log("util exports:", Object.keys(util));

// util.inherits uses Function internally?
console.log("\nutil.inherits:", util.inherits);
console.log("util.promisify:", util.promisify);
console.log("util.callbackify:", util.callbackify);

// Check if any util function can be abused
console.log("\n=== Testing util.format for format string attacks ===");
try {
  // Can we inject via format string?
  const result = util.format('%s', 'test');
  console.log("util.format result:", result);
} catch (e) {
  console.log("Error:", e.message);
}

console.log("\n=== Checking vm module exports ===");
const vm = require('vm');
console.log("vm exports:", Object.keys(vm));

// These are the dangerous ones
console.log("\nDangerous vm exports:");
console.log("  vm.runInThisContext:", typeof vm.runInThisContext);
console.log("  vm.runInNewContext:", typeof vm.runInNewContext);
console.log("  vm.runInContext:", typeof vm.runInContext);
console.log("  vm.compileFunction:", typeof vm.compileFunction);
console.log("  vm.Script:", typeof vm.Script);

console.log("\n=== Checking child_process exports ===");
const cp = require('child_process');
console.log("child_process exports:", Object.keys(cp));

console.log("\n=== Checking fs exports ===");
console.log("fs exports:", Object.keys(fs).slice(0, 20), "...");

console.log("\n=== Searching for modules that export 'Function' ===");

// Check if any module explicitly exports the Function constructor
// This would be very rare but possible

// Check process object
console.log("\n=== Checking process object ===");
console.log("process.binding:", typeof process.binding);
console.log("process.dlopen:", typeof process.dlopen);
console.log("process._linkedBinding:", typeof process._linkedBinding);

// These are internal and dangerous but not typically accessible
try {
  // This is the holy grail - if we can access this
  const binding = process.binding('fs');
  console.log("process.binding('fs'):", Object.keys(binding).slice(0, 10));
} catch (e) {
  console.log("process.binding error:", e.message);
}

console.log("\n=== SUMMARY ===");
console.log(`
To exploit CVE-2025-55182 without prototype pollution, we need:

1. A module in the webpack bundle that exports a dangerous function
2. Common candidates:
   - vm.runInThisContext(code) - executes JS
   - vm.compileFunction(code) - compiles JS
   - child_process.execSync(cmd) - runs shell
   - fs.readFileSync/writeFileSync - file access

3. The module must be in the Server Actions manifest (bundlerConfig)

4. Real-world scenarios where this could happen:
   - Server using EJS/Pug templates (bundles 'vm')
   - Server using sharp/puppeteer (bundles 'child_process')
   - Server with file upload (bundles 'fs')

The question is: Does Next.js or React bundle any of these?
`);

// Check what Next.js typically includes
console.log("\n=== Checking what a typical Next.js server action module looks like ===");
// The manifest format is: { [actionId]: { id: moduleId, chunks: [], name: exportName } }
// moduleId points to a webpack module ID
// exportName is the function name to access

console.log(`
Typical Server Action manifest entry:
{
  "abc123def456": {
    "id": "server-actions-chunk-12345",
    "chunks": ["server-actions-chunk-12345"],
    "name": "myServerAction"
  }
}

The vulnerability allows accessing:
  moduleExports["myServerAction"]  -> legitimate
  moduleExports["constructor"]     -> prototype chain!
  moduleExports["__proto__"]       -> prototype chain!

But moduleExports is the SERVER ACTIONS module, not fs/vm/child_process!
`);
