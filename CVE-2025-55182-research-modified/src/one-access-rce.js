/**
 * Finding RCE with ONE property access
 *
 * We have: moduleExports[name] where we control 'name'
 * We need: A property that IS a function that executes our args as code
 */

console.log("=== One Property Access RCE Research ===\n");

// The moduleExports is a plain JS object with server action functions
const moduleExports = {
  myAction: async (data) => ({ success: true }),
};

console.log("=== What prototype properties exist? ===");
const protoProps = Object.getOwnPropertyNames(Object.prototype);
console.log("Object.prototype properties:", protoProps);

// Check each one
console.log("\n=== Checking each prototype property ===");
for (const prop of protoProps) {
  const val = moduleExports[prop];
  console.log(`  ${prop}: ${typeof val}${typeof val === 'function' ? ' (callable)' : ''}`);
}

console.log("\n=== Can any of these execute code? ===");

// toString - returns "[object Object]"
console.log("toString():", moduleExports.toString());

// valueOf - returns the object itself
console.log("valueOf():", moduleExports.valueOf());

// hasOwnProperty - checks property existence
console.log("hasOwnProperty('test'):", moduleExports.hasOwnProperty('test'));

// None of these execute code from arguments!

console.log("\n=== What about Symbol properties? ===");
const symbolProps = Object.getOwnPropertySymbols(Object.prototype);
console.log("Symbol properties:", symbolProps);

console.log("\n=== What if moduleExports is a Function? ===");
// What if the server actions module exports a default function?
const functionModule = function defaultAction() { return "default"; };
functionModule.namedAction = async () => "named";

console.log("Function module prototype properties:");
const fnProtoProps = Object.getOwnPropertyNames(Function.prototype);
console.log(fnProtoProps);

// Check callable properties
for (const prop of fnProtoProps) {
  const val = functionModule[prop];
  if (typeof val === 'function') {
    console.log(`  ${prop}: callable`);
  }
}

// bind, call, apply are interesting but don't execute code directly
console.log("\nFunction.prototype.bind:", functionModule.bind);
console.log("Function.prototype.call:", functionModule.call);
console.log("Function.prototype.apply:", functionModule.apply);

// These require the function itself to be dangerous

console.log("\n=== What about Array prototype? ===");
const arrayModule = [async () => "action1", async () => "action2"];
console.log("Array prototype properties:", Object.getOwnPropertyNames(Array.prototype).slice(0, 15), "...");

// map, filter, reduce, etc. - execute callbacks but we'd need to pass a function

console.log("\n=== THE FUNDAMENTAL PROBLEM ===");
console.log(`
Every prototype method either:
1. Returns a primitive (toString, valueOf)
2. Returns a boolean (hasOwnProperty, isPrototypeOf)
3. Requires a function argument to execute (map, filter, etc.)
4. Returns another object (constructor)

None of them execute a STRING as code.

To execute a string as code, you need:
- eval(string)
- Function(string)
- vm.runInThisContext(string)
- new Function(string)

These are NOT on Object.prototype!
`);

console.log("\n=== Could there be a weird JS edge case? ===");

// What about Proxy?
console.log("Is there a global Proxy we could abuse?");
console.log("Proxy:", typeof Proxy);
// Proxy requires a target and handler, not useful

// What about Reflect?
console.log("Reflect:", typeof Reflect);
console.log("Reflect.construct:", Reflect.construct);
// Reflect.construct(Function, [code]) would work, but we can't chain two accesses

// What about with statement? (deprecated)
// Doesn't help in this context

console.log("\n=== Testing edge cases ===");

// Can we abuse type coercion?
const weirdObj = {
  [Symbol.toPrimitive]: (hint) => {
    console.log("toPrimitive called with hint:", hint);
    return "primitive";
  }
};

// moduleExports[Symbol.toPrimitive] would access this if it existed
// But we can't SET it on an existing object without prototype pollution

console.log("\n=== CONCLUSION ===");
console.log(`
With pure React RSC and NO pre-existing vulnerabilities:

CVE-2025-55182 allows ONE property access on moduleExports.
This gives access to prototype chain properties:
- constructor → [Function: Object]
- toString → [Function: toString]
- hasOwnProperty → [Function: hasOwnProperty]
- etc.

NONE of these can execute arbitrary code with one access.

RCE requires EITHER:
1. Pre-existing prototype pollution to add dangerous property
2. A module that exports dangerous functions directly
3. Two property accesses (constructor.constructor)

The vulnerability is REAL but requires additional conditions.
It's a "gadget" that needs another vulnerability to chain with.
`);

console.log("\n=== What about the 'bound' arguments? ===");
// The exploit also controls the 'bound' arguments
// fn.bind.apply(fn, [null].concat(bound))

// Even if fn = Object, calling Object(bound[0]) just wraps it
const fn = Object;
const bound = ["malicious code"];
const boundFn = fn.bind.apply(fn, [null].concat(bound));
console.log("Bound Object call:", boundFn());
// Returns String object, not code execution
