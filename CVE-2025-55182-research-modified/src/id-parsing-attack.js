/**
 * Deep dive into ID parsing attack surface
 *
 * The code parses: id = "moduleId#exportName"
 *
 * resolveServerReference looks up bundlerConfig[moduleId]
 * requireModule accesses moduleExports[exportName]
 *
 * Question: Can we manipulate the manifest lookup itself?
 */

console.log("=== ID Parsing Attack Analysis ===\n");

// The vulnerable code:
function resolveServerReference(bundlerConfig, id) {
  var name = "",
    resolvedModuleData = bundlerConfig[id];  // FIRST LOOKUP
  if (resolvedModuleData) {
    name = resolvedModuleData.name;
  } else {
    var idx = id.lastIndexOf("#");
    if (idx !== -1) {
      name = id.slice(idx + 1);                    // ATTACKER CONTROLS
      resolvedModuleData = bundlerConfig[id.slice(0, idx)];  // SECOND LOOKUP
    }
    if (!resolvedModuleData) {
      throw Error('Could not find module "' + id + '" in manifest');
    }
  }
  return [resolvedModuleData.id, resolvedModuleData.chunks, name];
}

// Sample manifest
const bundlerConfig = {
  "action123": {
    id: "server-chunk-1",
    chunks: [],
    name: "myAction"
  }
};

console.log("=== Attack Vector 1: Prototype chain on bundlerConfig lookup ===");

// What if id = "__proto__"?
console.log("bundlerConfig['__proto__']:", bundlerConfig['__proto__']);
console.log("bundlerConfig['constructor']:", bundlerConfig['constructor']);

// These don't have .id, .chunks, .name properties!
// So the lookup would fail to return valid metadata

console.log("\n=== Attack Vector 2: Inherited properties with right shape ===");

// What if we polluted Object.prototype to have the right shape?
// This requires a SEPARATE prototype pollution vulnerability

// Simulate prototype pollution (requires separate vuln):
// Object.prototype['polluted-action'] = {
//   id: 'ejs',  // Points to ejs module!
//   chunks: [],
//   name: 'render'
// };

console.log("If Object.prototype was polluted:");
console.log("  bundlerConfig['any-string'] would find the polluted entry");
console.log("  Then ejs.render would be called with attacker args");

console.log("\n=== Attack Vector 3: toString/valueOf abuse ===");

// What if id.lastIndexOf is manipulated?
// The id comes from the request, parsed as a string

const maliciousId = {
  lastIndexOf: () => -1,  // Always return -1, skip # parsing
  toString: () => "action123",  // Look up a valid entry
};

// But the id is received as a string from form data, not an object
// So this doesn't work

console.log("\n=== Attack Vector 4: What's in the manifest? ===");

// In Next.js, the manifest includes:
// - All server actions from 'use server' files
// - Each entry has: id (chunk ID), chunks (array), name (export name)

// The manifest is generated at BUILD TIME
// It's stored in the server and NOT sent to the client

// Key question: Are there any BUILT-IN entries we could access?

console.log("\n=== Attack Vector 5: Multiple # characters ===");

// id.lastIndexOf("#") finds the LAST #
// What about: "action123#safe#constructor"?

const id1 = "action123#safe#constructor";
const idx1 = id1.lastIndexOf("#");
console.log(`id: "${id1}"`);
console.log(`lastIndexOf("#"): ${idx1}`);
console.log(`name: "${id1.slice(idx1 + 1)}"`);
console.log(`moduleId: "${id1.slice(0, idx1)}"`);

// name = "constructor"
// moduleId = "action123#safe" (which probably doesn't exist)

// What about: "action123#constructor#"?
const id2 = "action123#constructor#";
const idx2 = id2.lastIndexOf("#");
console.log(`\nid: "${id2}"`);
console.log(`lastIndexOf("#"): ${idx2}`);
console.log(`name: "${id2.slice(idx2 + 1)}"`);  // empty string!
console.log(`moduleId: "${id2.slice(0, idx2)}"`);  // "action123#constructor"

// Interesting: name = "" means it uses default export!
// But moduleId would need to exist...

console.log("\n=== Attack Vector 6: Empty name handling ===");

// What happens when name = ""?
function requireModule(metadata) {
  var moduleExports = { default: "DEFAULT", myAction: "ACTION" };
  return "*" === metadata[2]
    ? moduleExports
    : "" === metadata[2]
      ? moduleExports.__esModule
        ? moduleExports.default
        : moduleExports
      : moduleExports[metadata[2]];
}

console.log('name = "":', requireModule(["chunk", [], ""]));
console.log('name = "*":', requireModule(["chunk", [], "*"]));
console.log('name = "constructor":', requireModule(["chunk", [], "constructor"]));

console.log("\n=== REAL ATTACK PATH ===");
console.log(`
The vulnerability is:
  moduleExports[attackerControlledName]

Where attackerControlledName comes from: id.slice(id.lastIndexOf("#") + 1)

To exploit:
1. Find a valid action ID in the manifest (e.g., "abc123")
2. Send: id = "abc123#constructor"
3. This resolves to the valid manifest entry
4. But accesses moduleExports["constructor"] instead of the real action

Result: moduleExports.constructor = [Function: Object]

To get RCE, we need EITHER:
a) moduleExports to have a dangerous property (not just prototype)
b) Two property accesses to reach Function constructor
c) A module that exports dangerous functions as own properties
`);

console.log("\n=== Testing the actual exploit ===");

// Real manifest entry
const manifest = {
  "valid-action": {
    id: "server-actions-chunk",
    chunks: [],
    name: "submitForm"
  }
};

// Real webpack modules
const __webpack_modules = {
  "server-actions-chunk": {
    submitForm: async () => "form submitted",
    // What else is on this object?
    // Only what the developer exported!
  }
};

function __webpack_require__(id) {
  return __webpack_modules[id];
}

// Attack: valid-action#constructor
const attackId = "valid-action#constructor";
const ref = resolveServerReference(manifest, attackId);
console.log("Reference:", ref);

const moduleExports = __webpack_require__(ref[0]);
console.log("Module exports:", moduleExports);
console.log("Module exports keys:", Object.keys(moduleExports));

const result = moduleExports[ref[2]];
console.log("Result:", result);
console.log("Type:", typeof result);

// We get Object constructor, but can't execute code with it
console.log("\nCalling Object('code'):", Object("process.exit()"));
// Just wraps the string, doesn't execute it
