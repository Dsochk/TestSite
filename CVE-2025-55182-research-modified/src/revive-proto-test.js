/**
 * Testing if reviveModel leads to prototype pollution
 */

const hasOwnProperty = Object.prototype.hasOwnProperty;

// Simplified reviveModel from vulnerable React RSC
function reviveModel(response, parentObj, parentKey, value, reference) {
  if ("string" === typeof value) {
    return value;
  }

  if ("object" === typeof value && null !== value) {
    if (Array.isArray(value)) {
      for (var i = 0; i < value.length; i++) {
        value[i] = reviveModel(response, value, "" + i, value[i], undefined);
      }
    } else {
      // Iterate over object properties
      for (var key in value) {
        if (hasOwnProperty.call(value, key)) {
          var revivedValue = reviveModel(response, value, key, value[key], undefined);

          // VULNERABLE: assigns to value[key] including __proto__
          if (revivedValue !== undefined) {
            value[key] = revivedValue;
          } else {
            delete value[key];
          }
        }
      }
    }
  }
  return value;
}

console.log("=== Before reviveModel ===");
console.log("{}.polluted:", {}.polluted);

// Create payload with __proto__
const payload = JSON.parse('{"__proto__": {"polluted": "PWNED"}, "normal": "test"}');
console.log("\nPayload:", payload);
console.log("Payload keys:", Object.keys(payload));
console.log("Payload hasOwn __proto__:", hasOwnProperty.call(payload, "__proto__"));

// Run through reviveModel
const result = reviveModel({}, {}, "", payload, undefined);
console.log("\n=== After reviveModel ===");
console.log("Result:", result);
console.log("{}.polluted:", {}.polluted);

// The simple assignment value[key] = revivedValue where key = "__proto__"
// Doesnt cause pollution because value already has __proto__ as own property

// BUT what if the value is used in Object.assign or spread later?
console.log("\n=== Testing if result can be used for pollution ===");
const obj = {};

// What does React do with the revived object?
// It returns it to be used as bound args or as the action result
// The action is called with: fn.bind.apply(fn, [null].concat(bound))

// What if bound = [payload] where payload has __proto__?
const fn = function(...args) {
  console.log("Function called with args:", args);
  return args;
};

const boundFn = fn.bind.apply(fn, [null].concat([result]));
console.log("Bound function result:", boundFn());

// Hmm, the __proto__ is just passed as a regular argument
