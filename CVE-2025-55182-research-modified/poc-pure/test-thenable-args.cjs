/**
 * Test: What arguments does V8 pass to .then()?
 *
 * When you await a thenable, V8 internally creates:
 *   Promise.resolve(thenable)
 *
 * Which calls:
 *   thenable.then(resolve, reject)
 *
 * But what ARE resolve and reject?
 */

'use strict';

console.log('='.repeat(60));
console.log('Test: Understanding thenable.then() arguments');
console.log('='.repeat(60));
console.log('');

// Test 1: What V8 passes to .then()
console.log('[1] What V8 passes to thenable.then():');
console.log('');

const capturedArgs = [];

const thenable = {
  then: function(...args) {
    console.log('  .then() called with', args.length, 'arguments');
    args.forEach((arg, i) => {
      console.log(`  arg[${i}] type:`, typeof arg);
      console.log(`  arg[${i}] name:`, arg.name);
      console.log(`  arg[${i}] toString():`, arg.toString().slice(0, 60));
      capturedArgs.push(arg);
    });
    // Resolve with something
    if (typeof args[0] === 'function') {
      args[0]('resolved!');
    }
  }
};

(async () => {
  const result = await thenable;
  console.log('');
  console.log('  Awaited result:', result);
})();

// Test 2: What happens with Function as .then
console.log('');
console.log('[2] What happens when .then = Function:');
console.log('');

setTimeout(() => {
  const funcThenable = {
    then: Function
  };

  // Simulate what V8 does internally
  console.log('  Simulating Promise.resolve(thenable):');
  console.log('');

  // V8 basically does this:
  // new Promise((resolve, reject) => {
  //   thenable.then(resolve, reject);
  // });

  const mockResolve = () => {};
  const mockReject = () => {};

  console.log('  resolve.toString():', mockResolve.toString());
  console.log('  reject.toString():', mockReject.toString());
  console.log('');

  console.log('  When Function(resolve, reject) is called:');
  console.log('  - Function receives: "() => {}", "() => {}"');
  console.log('  - Creates: function anonymous(/*resolve*/, /*reject*/) {}');
  console.log('');

  // Try it
  console.log('  Actual test:');
  try {
    const created = Function(mockResolve, mockReject);
    console.log('  Created function:', typeof created);
    console.log('  Function body:', created.toString());
  } catch (e) {
    console.log('  Error:', e.message);
    console.log('');
    console.log('  The error occurs because:');
    console.log('  - resolve.toString() = "() => {}"');
    console.log('  - This becomes the first PARAMETER NAME, not the body');
    console.log('  - "() => {}" is not a valid parameter name!');
  }

  console.log('');
  console.log('[3] Can we control what gets passed to .then()?');
  console.log('');
  console.log('  In the Promise spec, then() always receives:');
  console.log('  - resolve: A function that fulfills the promise');
  console.log('  - reject: A function that rejects the promise');
  console.log('');
  console.log('  We cannot control these - they are V8 internals.');
  console.log('');
  console.log('  BUT: What if there is another code path that');
  console.log('  calls .then() with attacker-controlled arguments?');
  console.log('');

}, 100);

// Test 3: Can we get different .then() behavior?
setTimeout(() => {
  console.log('[4] Exploring other thenable patterns:');
  console.log('');

  // What if we use .then in a non-await context?
  const obj = {
    then: function(a, b) {
      console.log('  .then() called');
      console.log('  First arg type:', typeof a);
      console.log('  Second arg type:', typeof b);

      if (typeof a === 'function') {
        return a('called as thenable');
      }
      return a;
    }
  };

  // Promise.resolve calls .then()
  console.log('  [4a] Promise.resolve():');
  Promise.resolve(obj).then(r => console.log('  Result:', r));

  // But what about direct .then() call?
  console.log('');
  console.log('  [4b] Direct .then(value) call:');
  const directResult = obj.then('CONTROLLED_VALUE');
  console.log('  Result:', directResult);

  console.log('');
  console.log('  KEY INSIGHT:');
  console.log('  - await/Promise.resolve always pass functions');
  console.log('  - But if code does: obj.then(userInput)');
  console.log('  - We could control the argument!');
  console.log('');
  console.log('  Question: Does React/Next.js ever call .then()');
  console.log('  with controlled arguments instead of await?');

}, 200);
