/**
 * Pure React RSC Server - CVE-2025-55182 PoC
 *
 * This sets up the ACTUAL react-server-dom-webpack environment
 * without Next.js or other frameworks.
 */

import http from 'http';
import { Readable } from 'stream';

// ============================================================
// STEP 1: Set up webpack globals BEFORE importing React
// ============================================================

// Server manifest - maps action IDs to modules
// In real apps, this is generated by webpack at build time
const SERVER_MANIFEST = {
  // A legitimate server action
  'file:///app/actions.js#submitForm': {
    id: 'actions-chunk',
    chunks: [],
    name: 'submitForm'
  }
};

// Simulated webpack modules (what webpack bundles)
const WEBPACK_MODULES = {
  'actions-chunk': {
    submitForm: async function(formData) {
      console.log('[ACTION] submitForm called with:', formData);
      return { success: true, message: 'Form submitted' };
    }
  }
};

// Set up webpack's require function
globalThis.__webpack_require__ = function(moduleId) {
  console.log(`[WEBPACK] __webpack_require__("${moduleId}")`);

  if (WEBPACK_MODULES[moduleId]) {
    return WEBPACK_MODULES[moduleId];
  }

  throw new Error(`Module not found: ${moduleId}`);
};

// Set up webpack's chunk loader
globalThis.__webpack_chunk_load__ = function(chunkId) {
  console.log(`[WEBPACK] __webpack_chunk_load__("${chunkId}")`);
  return Promise.resolve();
};

// ============================================================
// STEP 2: Import React RSC after webpack globals are set
// ============================================================

// Use production build
process.env.NODE_ENV = 'production';

// Import the vulnerable library
const ReactServerDOMWebpack = await import('react-server-dom-webpack/server.node');
const { decodeAction, decodeReply } = ReactServerDOMWebpack;

console.log('='.repeat(60));
console.log('CVE-2025-55182 Pure React RSC Server');
console.log('='.repeat(60));
console.log('Loaded react-server-dom-webpack@19.0.0 (VULNERABLE)');
console.log('Available exports:', Object.keys(ReactServerDOMWebpack));
console.log('');

// ============================================================
// STEP 3: HTTP Server that processes Server Actions
// ============================================================

const server = http.createServer(async (req, res) => {
  console.log(`\n[${new Date().toISOString()}] ${req.method} ${req.url}`);

  // CORS headers for testing
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

  if (req.method === 'OPTIONS') {
    res.writeHead(200);
    res.end();
    return;
  }

  if (req.method === 'GET' && req.url === '/') {
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({
      status: 'running',
      vulnerability: 'CVE-2025-55182',
      library: 'react-server-dom-webpack@19.0.0',
      endpoints: {
        'POST /action': 'Process server action (vulnerable)'
      }
    }));
    return;
  }

  if (req.method === 'POST' && req.url === '/action') {
    try {
      // Collect the request body
      const chunks = [];
      for await (const chunk of req) {
        chunks.push(chunk);
      }
      const body = Buffer.concat(chunks);

      // Parse multipart form data manually
      const contentType = req.headers['content-type'] || '';
      console.log('[REQUEST] Content-Type:', contentType);
      console.log('[REQUEST] Body length:', body.length);

      let formData;

      if (contentType.includes('multipart/form-data')) {
        formData = parseMultipartFormData(body, contentType);
      } else if (contentType.includes('application/x-www-form-urlencoded')) {
        formData = parseUrlEncoded(body.toString());
      } else {
        // Assume it's already FormData-like
        formData = new Map();
        const params = new URLSearchParams(body.toString());
        for (const [key, value] of params) {
          formData.set(key, value);
        }
      }

      console.log('[PARSED] FormData entries:');
      for (const [key, value] of formData.entries()) {
        const displayValue = typeof value === 'string' && value.length > 100
          ? value.substring(0, 100) + '...'
          : value;
        console.log(`  ${key} = ${displayValue}`);
      }

      // Call the REAL decodeAction from react-server-dom-webpack
      console.log('\n[DECODE] Calling decodeAction...');
      const actionPromise = decodeAction(formData, SERVER_MANIFEST);

      if (actionPromise === null) {
        console.log('[DECODE] No action found in request');
        res.writeHead(400, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'No action found' }));
        return;
      }

      console.log('[DECODE] Got action promise, awaiting...');
      const boundAction = await actionPromise;

      console.log('[DECODE] Action type:', typeof boundAction);

      if (typeof boundAction === 'function') {
        console.log('[EXECUTE] Calling bound action...');
        const result = await boundAction();
        console.log('[EXECUTE] Result:', result);

        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ success: true, result }));
      } else {
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ success: true, action: 'decoded' }));
      }

    } catch (error) {
      console.error('[ERROR]', error.message);
      console.error('[STACK]', error.stack);
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: error.message, stack: error.stack }));
    }
    return;
  }

  res.writeHead(404);
  res.end('Not found');
});

// ============================================================
// Helper: Parse multipart form data
// ============================================================

function parseMultipartFormData(body, contentType) {
  const formData = new Map();

  // Extract boundary
  const boundaryMatch = contentType.match(/boundary=(?:"([^"]+)"|([^;]+))/);
  if (!boundaryMatch) {
    throw new Error('No boundary in multipart form data');
  }
  const boundary = boundaryMatch[1] || boundaryMatch[2];

  const bodyStr = body.toString('binary');
  const parts = bodyStr.split('--' + boundary);

  for (const part of parts) {
    if (part.trim() === '' || part.trim() === '--') continue;

    const headerEnd = part.indexOf('\r\n\r\n');
    if (headerEnd === -1) continue;

    const headers = part.substring(0, headerEnd);
    const content = part.substring(headerEnd + 4).replace(/\r\n$/, '');

    const nameMatch = headers.match(/name="([^"]+)"/);
    if (nameMatch) {
      formData.set(nameMatch[1], content);
    }
  }

  return formData;
}

function parseUrlEncoded(body) {
  const formData = new Map();
  const params = new URLSearchParams(body);
  for (const [key, value] of params) {
    formData.set(key, value);
  }
  return formData;
}

// ============================================================
// Start server
// ============================================================

const PORT = 3003;
server.listen(PORT, () => {
  console.log(`\nServer listening on http://localhost:${PORT}`);
  console.log('\nEndpoints:');
  console.log('  GET  /        - Server info');
  console.log('  POST /action  - Process server action (VULNERABLE)');
  console.log('\nReady for exploitation!');
  console.log('='.repeat(60));
});
