/**
 * TEST: Making [object FormData] valid JavaScript
 *
 * When decodeAction calls the bound Function:
 *   Function.bind(null, ...boundArgs).bind(null, formData)()
 *   = Function(...boundArgs, formData)
 *   = Function(...boundArgs, "[object FormData]")  // formData.toString()
 *
 * The last arg is the function body. If we control boundArgs,
 * we can make the body "[object FormData]" be valid JS!
 *
 * [object, FormData] is a valid JS expression - an array literal
 * that evaluates to the last element (FormData).
 *
 * If "object" and "FormData" are defined as function parameters,
 * the expression is valid!
 */

'use strict';

console.log('='.repeat(60));
console.log('Making [object FormData] valid JavaScript');
console.log('='.repeat(60));
console.log('');

// ============================================================
// Theory: Array literal syntax
// ============================================================

console.log('THEORY:');
console.log('  "[object FormData]" is NOT valid JS by itself');
console.log('  But [ object, FormData ] IS valid JS!');
console.log('  (An array literal that evaluates to its last element)');
console.log('');

// The actual toString of FormData:
const realFormData = new FormData();
console.log('FormData.toString():', realFormData.toString());
// Output: "[object FormData]"

// But we need Map since that's what the test uses
const mapData = new Map();
console.log('Map.toString():', mapData.toString());
// Output: "[object Map]"

console.log('');
console.log('So the body becomes: [object Map]');
console.log('We need to make [object, Map] valid by defining these params');
console.log('');

// ============================================================
// Test: Function with parameter names to make body valid
// ============================================================

console.log('TEST 1: Direct Function constructor');
console.log('-'.repeat(40));

// If boundArgs = ["object", "Map"]
// Then: Function("object", "Map", "[object Map]")
// Creates: function anonymous(object, Map) { [object, Map] }
// The body [object, Map] is an array expression returning Map param

try {
  const fn = Function("object", "Map", "[object, Map]");
  console.log('Created function:', fn.toString().slice(0, 100));

  // Call with arguments
  const result = fn("arg1", "MY_VALUE");
  console.log('Result:', result);
  console.log('');

  if (result === "MY_VALUE") {
    console.log('✓ The function returns the second parameter!');
    console.log('');
  }
} catch (e) {
  console.error('Error:', e.message);
}

// ============================================================
// Test: Injecting code via the Map parameter value
// ============================================================

console.log('TEST 2: RCE via Map parameter');
console.log('-'.repeat(40));

// If we call the created function with:
//   (anything, <our code result>)
// It returns <our code result>!
//
// But wait - who calls this function?
// In decodeAction: boundAction() is called with no args
// So object=undefined, Map=undefined, returns undefined
//
// Actually the bound action IS called with formData!
// No wait - let me check the flow again...
//
// loadServerReference returns: fn.bind(null, ...bound)
// decodeAction does: action.then(fn => fn.bind(null, formData))
// Final call: boundAction()
//
// So the function has:
//   - bound args from server
//   - then formData bound
//   - called with () no args
//
// fn.bind(null, ...bound) = partial application
// result.bind(null, formData) = adds formData as next arg
// result() calls with those pre-bound args
//
// If bound = ["object", "Map"], then:
//   Function.bind(null, "object", "Map") = partial Function with 2 args
//   result.bind(null, formData) = Function("object", "Map", formData)
//   result() = Function("object", "Map", "[object Map]")
//   = function(object, Map) { [object, Map] }
//   = This creates the function but doesn't call it!
//
// The RESULT of decodeAction is a function factory!
// Calling boundAction() creates a new function.
// We need to call it TWICE: boundAction()() to execute the body.
//
// But the body [object, Map] just returns the Map parameter value.
// And we don't control what's passed when it's called.

console.log('Problem: The body [object, Map] returns a parameter value');
console.log('But when the created function is called, we don\'t control params');
console.log('');

// ============================================================
// Test: Can we inject executable code?
// ============================================================

console.log('TEST 3: Code injection via Map parameter');
console.log('-'.repeat(40));

// What if Map parameter itself is code that gets executed?
// [object, Map] evaluates Map, but doesn't call it.
//
// Unless... we use a getter or Proxy?
// No, that's too complex for this attack.
//
// Alternative: Make the body more than just [object, Map]
// Can we append code after the body?
//
// The body is "[object Map]" (with space, not comma!)
// Actually let me check again...

console.log('What is FormData.prototype.toString behavior?');

class TestClass {}
const testObj = new TestClass();
console.log('Object toString:', testObj.toString());
console.log('Map toString:', mapData.toString());
console.log('FormData toString:', realFormData.toString());
console.log('');

// All are "[object ClassName]" format
// With a SPACE, not comma!
// So [object Map] is actually: [ object Map ]
// That's a syntax error - "Map" is unexpected after "object"

console.log('Wait - "[object Map]" has a space, not comma!');
console.log('So it\'s NOT a valid array literal.');
console.log('Let me verify...');
console.log('');

try {
  // This should fail
  const bad = Function("[object Map]");
  console.log('Surprisingly valid?', bad.toString());
} catch (e) {
  console.log('✓ Confirmed: "[object Map]" is NOT valid JS');
  console.log('Error:', e.message);
}

console.log('');

// ============================================================
// New approach: Can we make "[object <space> Map]" valid?
// ============================================================

console.log('TEST 4: Making "[object Map]" parseable');
console.log('-'.repeat(40));

// "[object Map]" with space is: [ object Map ]
// In JS, this tries to index an array with "object Map"
// Which evaluates as: object Map (two identifiers = syntax error)
//
// BUT! What if we define variables to make it work?
// "object Map" could be: object <ASI> Map if statements are separate
// No, that doesn't work in array context
//
// Actually "object Map" in [ ] is trying to:
//   - Evaluate "object"
//   - Then... syntax error because Map is unexpected
//
// Unless Map is a suffix operator? No such thing in JS.
//
// Alternative approach:
// What if object is a tagged template literal function?
// object`Map` would work if object is defined as a function!
// But we have object Map (space), not object`Map` (backticks)

console.log('The space between "object" and "Map" is the problem.');
console.log('We need creative solutions...');
console.log('');

// ============================================================
// Alternative: Control the formData.toString()
// ============================================================

console.log('TEST 5: Custom toString');
console.log('-'.repeat(40));

// What if the Map/FormData has a custom toString?
// We can't modify native objects, but in the attack:
// - formData is created fresh in decodeAction
// - We don't control its toString

// Unless... prototype pollution?
// If Map.prototype.toString is polluted, we control the body!
// But that requires a separate prototype pollution vulnerability.

console.log('We cannot control formData.toString() from the payload.');
console.log('');

// ============================================================
// Alternative: Use different Function overloads
// ============================================================

console.log('TEST 6: Function constructor with multiple args');
console.log('-'.repeat(40));

// Function(p1, p2, ..., pN, body)
// All but last args are parameter names
// Last arg is the body
//
// What if body comes BEFORE formData?
// If bound = ["param1", "return 1+1"]
// Then: Function("param1", "return 1+1", "[object Map]")
// Creates: function(param1) { return 1+1 }  <-- body is "return 1+1"?
//
// NO! With 3 args: params are "param1" and "return 1+1", body is "[object Map]"
// The LAST arg is always the body.

console.log('Function constructor: last arg is ALWAYS the body');
console.log('We cannot avoid [object Map] being the body');
console.log('');

// ============================================================
// Alternative: Make it a comment
// ============================================================

console.log('TEST 7: Commenting out the invalid body');
console.log('-'.repeat(40));

// What if bound args end with code that comments out the body?
// bound = ["param1; return process.version //"]
// Function("param1; return process.version //", "[object Map]")
// Creates: function(param1; return process.version //) { [object Map] }
//
// NO! Parameter names must be valid identifiers.
// "param1; return..." is not valid as a param name.

console.log('Cannot inject code into parameter names.');
console.log('');

// ============================================================
// Alternative: Zero-width characters or special encoding
// ============================================================

console.log('TEST 8: Examining exact toString format');
console.log('-'.repeat(40));

const mapStr = mapData.toString();
console.log('Map toString hex:');
for (let i = 0; i < mapStr.length; i++) {
  console.log(`  ${i}: '${mapStr[i]}' = 0x${mapStr.charCodeAt(i).toString(16)}`);
}
console.log('');

// It's literally: [ o b j e c t   M a p ]
// The space (0x20) is the problem.

// ============================================================
// CONCLUSION
// ============================================================

console.log('='.repeat(60));
console.log('CONCLUSION');
console.log('='.repeat(60));
console.log('');
console.log('The decodeAction path cannot be exploited for RCE because:');
console.log('  1. formData.toString() = "[object FormData]" (or "[object Map]")');
console.log('  2. This becomes the Function body (last arg)');
console.log('  3. "[object Map]" is NOT valid JavaScript (space, not comma)');
console.log('  4. We cannot control or comment out the body');
console.log('');
console.log('HOWEVER:');
console.log('  - decodeReply DOES work for RCE');
console.log('  - It returns the raw value without binding formData');
console.log('  - Real-world applicability depends on who uses decodeReply');
console.log('');
console.log('Real-world scenarios for decodeReply:');
console.log('  - Custom RSC implementations');
console.log('  - Replay/resume functionality');
console.log('  - Server-to-server RSC communication');
console.log('');
