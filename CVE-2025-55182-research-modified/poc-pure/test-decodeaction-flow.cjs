/**
 * Test: decodeAction complete flow analysis
 *
 * decodeAction flow:
 * 1. Parse metadata from $ACTION_REF_X
 * 2. loadServerReference(manifest, id, bound)
 * 3. fn.bind.apply(fn, [null].concat(bound))
 * 4. result.bind(null, formData)
 *
 * If fn = Function and bound = ["code"]:
 * Step 3: Function.bind(null, "code") -> boundFn
 * Step 4: boundFn.bind(null, formData) -> doubleBoundFn
 *
 * When called: doubleBoundFn()
 * = boundFn(formData)
 * = Function("code")(formData)  <- formData passed as arg to created function
 * = createdFn(formData)
 */

'use strict';

console.log('='.repeat(60));
console.log('Test: decodeAction flow simulation');
console.log('='.repeat(60));
console.log('');

// Simulate the flow step by step

console.log('[1] What loadServerReference returns (step 3):');
console.log('');

const fn = Function;  // We get Function via vulnerability
const bound = ['return "RCE_CODE"'];  // Our code

// Step 3: fn.bind.apply(fn, [null].concat(bound))
const step3Result = fn.bind.apply(fn, [null].concat(bound));
console.log('  fn.bind.apply(fn, [null, "return \\"RCE_CODE\\""]):');
console.log('  Type:', typeof step3Result);
console.log('  step3Result():', step3Result());
console.log('  step3Result()():', step3Result()());
console.log('');

console.log('[2] What decodeAction returns (step 4):');
console.log('');

const formData = new FormData();
formData.append('test', 'value');

// Step 4: step3Result.bind(null, formData)
const step4Result = step3Result.bind(null, formData);
console.log('  step3Result.bind(null, formData):');
console.log('  Type:', typeof step4Result);
console.log('');

console.log('[3] What happens when Next.js calls the action:');
console.log('');

// Next.js does: await boundAction()
// Which calls step4Result()
try {
  const actionResult = step4Result();
  console.log('  step4Result() =', actionResult);
  console.log('  Type:', typeof actionResult);

  if (typeof actionResult === 'function') {
    console.log('');
    console.log('  The created function has formData as first param!');
    console.log('  Calling actionResult():');
    const finalResult = actionResult();
    console.log('  Result:', finalResult);
  }
} catch (e) {
  console.log('  Error:', e.message);
}

console.log('');
console.log('[4] The problem explained:');
console.log('');
console.log('  Function.bind(null, "code").bind(null, formData)()');
console.log('  = Function.bind(null, "code")(formData)');
console.log('  = Function("code", formData.toString())');
console.log('  = Function("code", "[object FormData]")');
console.log('');
console.log('  The function body becomes: "code"');
console.log('  With parameter named: "[object FormData]"');
console.log('');

// Let's see exactly what happens
console.log('[5] Exact result:');
console.log('');

const exactFn = Function('return "RCE"', '[object FormData]');
console.log('  Function("return \\"RCE\\"", "[object FormData]"):');
console.log('  Result:', exactFn.toString());

// The issue: "[object FormData]" is not a valid param name
// BUT wait... Function() with multiple args uses last as body!

console.log('');
console.log('[6] Wait - Function behavior with multiple args:');
console.log('');
console.log('  Function(arg1, arg2, ..., body)');
console.log('  Last argument is body, rest are param names!');
console.log('');

const f1 = Function('a', 'return a');
console.log('  Function("a", "return a"):', f1.toString());
console.log('  f1(42):', f1(42));

const f2 = Function('a', 'b', 'return a + b');
console.log('  Function("a", "b", "return a + b"):', f2.toString());
console.log('  f2(1,2):', f2(1,2));

console.log('');
console.log('[7] So with decodeAction:');
console.log('');
console.log('  Function("our_code", "[object FormData]")');
console.log('  = function("our_code") { [object FormData] }');
console.log('');
console.log('  "our_code" becomes the PARAM NAME');
console.log('  "[object FormData]" becomes the BODY');
console.log('  But "[object FormData]" is not valid JS!');
console.log('');

try {
  const broken = Function('param', '[object FormData]');
  console.log('  Result:', broken.toString());
} catch (e) {
  console.log('  Error:', e.message);
}

console.log('');
console.log('[8] Can we craft code that survives this?');
console.log('');

// We need our code to be the LAST argument (the body)
// But formData always gets appended after our bound args

// What if bound = [] (empty)?
// Then: Function.bind(null).bind(null, formData)()
// = Function.bind(null)(formData)
// = Function(formData)
// = Function("[object FormData]")
// Still broken!

// What if we put formData handling in our code?
// Our code needs to be the body, not formData string

console.log('  The architecture of decodeAction makes this hard:');
console.log('  - Our code becomes param name');
console.log('  - formData.toString() becomes body');
console.log('  - "[object FormData]" is not valid JS');
console.log('');
