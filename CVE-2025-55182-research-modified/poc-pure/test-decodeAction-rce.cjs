/**
 * Exploring decodeAction RCE possibilities
 *
 * The challenge: decodeAction always does fn.bind(null, formData) at the end
 * formData.toString() = "[object FormData]" becomes Function body = syntax error
 *
 * Can we find another path to RCE?
 */

'use strict';

// ============================================================
// Setup
// ============================================================

let webpackModuleIdx = 0;
const webpackServerModules = {};
const webpackServerMap = {};

global.__webpack_chunk_load__ = id => Promise.resolve();
global.__webpack_require__ = id => webpackServerModules[id];

process.env.NODE_ENV = 'production';

require.cache[require.resolve('react')] = {
  id: require.resolve('react'),
  filename: require.resolve('react'),
  loaded: true,
  exports: {
    __SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE: { H: null, A: null },
    version: '19.0.0',
  }
};

const { decodeAction } = require('react-server-dom-webpack/server.node');

function registerModule(exports) {
  const idx = '' + webpackModuleIdx++;
  webpackServerModules[idx] = exports;
  const path = 'file:///' + idx;
  webpackServerMap[path] = { id: idx, chunks: [], name: '*' };

  if (typeof exports === 'object' && exports !== null) {
    for (const name in exports) {
      webpackServerMap[path + '#' + name] = { id: idx, chunks: [], name };
    }
  }
  // Always register constructor access
  webpackServerMap[path + '#constructor'] = { id: idx, chunks: [], name: 'constructor' };

  return path;
}

// ============================================================
// IDEA 1: What if we use Function.prototype.call or apply?
// ============================================================

console.log('='.repeat(60));
console.log('IDEA 1: Function.prototype.call/apply');
console.log('='.repeat(60));

// If we get Function.prototype.call:
// call.bind(null, formData)()
// = call(formData) - calls call with formData as this
// = formData.call() - formData doesn't have call method... error

console.log('Function.prototype.call:', typeof Function.prototype.call);
console.log('Bound call behavior: call.bind(null, formData)() would fail');
console.log('');

// ============================================================
// IDEA 2: What about toString/valueOf that could execute code?
// ============================================================

console.log('='.repeat(60));
console.log('IDEA 2: toString/valueOf');
console.log('='.repeat(60));

// Even if we return a custom toString, it doesn't help
// because we need the RESULT of calling boundAction() to be useful
console.log('toString/valueOf don\'t help - they\'re called on conversion, not execution');
console.log('');

// ============================================================
// IDEA 3: What if bound contains a Proxy with get trap?
// ============================================================

console.log('='.repeat(60));
console.log('IDEA 3: Proxy objects');
console.log('='.repeat(60));

// Proxies can't be serialized in JSON/Flight protocol
console.log('Proxies cannot be serialized in the Flight protocol');
console.log('');

// ============================================================
// IDEA 4: What if the "action" isn't called at all?
// ============================================================

console.log('='.repeat(60));
console.log('IDEA 4: Thenable exploitation');
console.log('='.repeat(60));

// decodeAction returns: action.then(fn => fn.bind(null, formData))
// What if action resolves to something that, when .then() is called,
// executes our code?

// Actually, the flow is:
// 1. loadServerReference returns a Promise
// 2. decodeAction does: action.then(fn => fn.bind(null, formData))
// 3. The returned promise is what we get

// What if loadServerReference's promise, when resolved, gives us control?
// The Promise.all resolves with [bound, moduleLoad]
// Then fn = requireModule(serverReference)

// We control serverReference via the ID!
// But requireModule still needs to return something callable for bind()

console.log('The action must resolve to something with .bind() method');
console.log('');

// ============================================================
// IDEA 5: What if bound args include code that runs during bind?
// ============================================================

console.log('='.repeat(60));
console.log('IDEA 5: Side effects during bind');
console.log('='.repeat(60));

// bind.apply(fn, [null].concat(bound))
// concat() could trigger valueOf/toString on bound elements
// But those don't execute arbitrary code

// What if bound contains an object with [Symbol.toPrimitive]?
// Can't serialize symbols in JSON

console.log('Cannot exploit bind() side effects with serializable data');
console.log('');

// ============================================================
// IDEA 6: What if we return an already-executed result?
// ============================================================

console.log('='.repeat(60));
console.log('IDEA 6: Return pre-computed result');
console.log('='.repeat(60));

// If fn is not Function but a regular function that ignores formData...
// fn.bind(null, formData) returns a bound function
// Calling it: fn(formData)
// If fn returns something we control, that's not RCE

// We need fn to EXECUTE our code when called
// The only way is if fn IS Function (or eval, etc.)

console.log('Need fn to be an executor like Function/eval');
console.log('');

// ============================================================
// IDEA 7: Chained server references
// ============================================================

console.log('='.repeat(60));
console.log('IDEA 7: Chained $F references');
console.log('='.repeat(60));

// What if bound contains another $F reference?
// $F triggers loadServerReference$1 which...
// Returns a Promise that resolves to a bound function

// So bound = [$F_result] where $F_result is Function.bind(null, "code")
// Then: Function.bind.apply(Function, [null, $F_result])
// = Function.bind(null, $F_result)
// Then: .bind(null, formData)
// Final call: Function($F_result, formData)
// = Function(boundFunction, "[object FormData]")
// Body is still formData!

console.log('Chained references still result in formData as body');
console.log('');

// ============================================================
// IDEA 8: The $ prefix fallback in parseModelString
// ============================================================

console.log('='.repeat(60));
console.log('IDEA 8: Unknown $ prefix handling');
console.log('='.repeat(60));

// Line 2637-2638: If value[1] doesn't match known cases:
// value = value.slice(1);
// return getOutlinedModel(response, value, obj, key, createModel);

// So "$X1:foo:bar" would become "X1:foo:bar" and do path traversal!
// But createModel just returns the value - doesn't execute anything

console.log('Unknown $ prefixes just return the traversed value');
console.log('');

// ============================================================
// IDEA 9: What if formData is empty or has special toString?
// ============================================================

console.log('='.repeat(60));
console.log('IDEA 9: Control formData');
console.log('='.repeat(60));

// decodeAction creates formData internally:
// var formData = new FormData()
// We can't control its toString()

// BUT - formData only gets non-$ACTION_ keys appended
// If ALL our keys start with $ACTION_, formData stays empty!
// Empty FormData.toString() = "[object FormData]" - still invalid

const emptyFD = new FormData();
console.log('Empty FormData.toString():', emptyFD.toString());
console.log('Still "[object FormData]" - no bypass');
console.log('');

// ============================================================
// IDEA 10: Use a different callable that handles bad syntax
// ============================================================

console.log('='.repeat(60));
console.log('IDEA 10: Alternative executors');
console.log('='.repeat(60));

// What callables exist that:
// 1. Are on the prototype chain (accessible via #property)
// 2. When called with formData, execute something useful

// - Object: Object(formData) = wraps formData, no execution
// - Function: Function(formData) = syntax error
// - Array: Array(formData) = creates array, no execution
// - String: String(formData) = "[object FormData]"
// - Number: Number(formData) = NaN
// - Boolean: Boolean(formData) = true

// What about:
// - Error: Error(formData) = creates error object
// - RegExp: RegExp(formData) = creates regex from "[object FormData]"
// - Date: Date(formData) = Invalid Date

// None of these execute code!

console.log('No prototype constructor executes arbitrary code');
console.log('');

// ============================================================
// CONCLUSION
// ============================================================

console.log('='.repeat(60));
console.log('CONCLUSION');
console.log('='.repeat(60));
console.log('');
console.log('decodeAction RCE appears blocked because:');
console.log('1. formData.toString() = "[object FormData]" (invalid JS)');
console.log('2. formData is ALWAYS bound as the last argument');
console.log('3. Function\'s last argument is ALWAYS the body');
console.log('4. We cannot control formData\'s toString()');
console.log('5. We cannot avoid the .bind(null, formData) call');
console.log('');
console.log('The only path to RCE seems to be decodeReply which:');
console.log('- Returns the raw value without formData binding');
console.log('- Allows full control over Function arguments');
console.log('');
console.log('HOWEVER - in real Next.js, decodeReply IS used!');
console.log('Server Functions use it for argument deserialization.');
console.log('');
