/**
 * Test: What exactly does V8 pass to .then()?
 *
 * When you do: await { then: Function }
 * V8 calls: thenable.then(resolve, reject)
 *
 * Function receives these as arguments - but HOW does it interpret them?
 */

'use strict';

console.log('='.repeat(60));
console.log('Test: Understanding Function() argument handling');
console.log('='.repeat(60));
console.log('');

// Test 1: What are resolve/reject?
console.log('[1] What V8 passes to .then():');

const thenable = {
  then: function(resolve, reject) {
    console.log('  resolve type:', typeof resolve);
    console.log('  resolve.name:', resolve.name);
    console.log('  resolve.toString():', resolve.toString());
    console.log('  reject type:', typeof reject);
    console.log('  reject.toString():', reject.toString());
    resolve('done');
  }
};

(async () => {
  await thenable;
})();

setTimeout(() => {
  console.log('');
  console.log('[2] How Function() interprets arguments:');
  console.log('');

  // Function(arg1, arg2, ..., body)
  // Last argument is body, all others are parameter names

  console.log('  Function("a", "b", "return a+b"):');
  const f1 = Function("a", "b", "return a+b");
  console.log('    Result:', f1.toString());
  console.log('    f1(1,2):', f1(1,2));

  console.log('');
  console.log('  Function("return 42"):');
  const f2 = Function("return 42");
  console.log('    Result:', f2.toString());
  console.log('    f2():', f2());

  console.log('');
  console.log('[3] What happens with Function(resolve, reject)?');
  console.log('');

  // When .then = Function and await calls it:
  // Function(resolve, reject)
  // resolve and reject are FUNCTIONS
  // Function coerces them to strings for parameter names

  const mockResolve = function namedResolve() {};
  const mockReject = function namedReject() {};

  console.log('  mockResolve.toString():', mockResolve.toString());

  try {
    const f3 = Function(mockResolve, mockReject);
    console.log('  Function(mockResolve, mockReject):', f3.toString());
  } catch (e) {
    console.log('  Error:', e.message);
  }

  console.log('');
  console.log('[4] The coercion problem:');
  console.log('');
  console.log('  Function(fn1, fn2) tries to use fn1.toString() as param name');
  console.log('  fn1.toString() = "function namedResolve() {}"');
  console.log('  This is NOT a valid JavaScript identifier!');
  console.log('');

  console.log('[5] Can we control what toString() returns?');
  console.log('');

  // What if we had an object with custom toString?
  const customObj = {
    toString: () => 'a',  // Valid param name!
  };

  try {
    const f4 = Function(customObj, 'return a * 2');
    console.log('  Function({toString: () => "a"}, "return a * 2"):');
    console.log('    Result:', f4.toString());
    console.log('    f4(21):', f4(21));
  } catch (e) {
    console.log('  Error:', e.message);
  }

  console.log('');
  console.log('[6] But we can\'t control V8\'s resolve/reject functions...');
  console.log('    They are native functions created by V8 internally.');
  console.log('    We cannot modify their toString() method.');
  console.log('');

  // The only way would be if we could make .then receive something OTHER than
  // V8's native resolve/reject functions

  console.log('[7] Alternative: What if we call .then() ourselves?');
  console.log('');

  const exploitObj = {
    then: Function  // Function constructor as .then
  };

  // If WE call .then() with our strings instead of V8:
  console.log('  exploitObj.then("return 42"):');
  try {
    const created = exploitObj.then("return 42");
    console.log('    Type:', typeof created);
    console.log('    Result:', created.toString());
    console.log('    created():', created());
    console.log('');
    console.log('  âœ“ This works! But needs something to call .then() with our string.');
  } catch (e) {
    console.log('  Error:', e.message);
  }

  console.log('');
  console.log('[8] Does React/Next.js ever call .then(value) directly?');
  console.log('    (instead of await which passes resolve/reject)');
  console.log('');

}, 100);
